{"ast":null,"code":"import { logger, hasWindow, isFunction, scheduleIdleWork } from \"@rpldy/shared\";\nimport createState from \"@rpldy/simple-state\";\nimport { SENDER_EVENTS, UPLOADER_EVENTS } from \"../consts\";\nimport processQueueNext from \"./processQueueNext\";\nimport { processAbortItem, processAbortBatch, processAbortAll } from \"./processAbort\";\nimport { detachRecycledFromPreviousBatch, getBatchFromState, preparePendingForUpload, removePendingBatches, clearBatchData, cancelBatchWithId, triggerUploaderBatchEvent } from \"./batchHelpers\";\nconst createUploaderQueue = (options, trigger, cancellable, sender, uploaderId) => {\n  const {\n    state,\n    update\n  } = createState({\n    itemQueue: {},\n    batchQueue: [],\n    currentBatch: null,\n    batchesStartPending: [],\n    batches: {},\n    items: {},\n    activeIds: [],\n    aborts: {}\n  });\n  const getState = () => state;\n  const updateState = updater => {\n    update(updater);\n  };\n  const add = item => {\n    if (state.items[item.id] && !item.recycled) {\n      throw new Error(`Uploader queue conflict - item ${item.id} already exists`);\n    }\n    if (item.recycled) {\n      detachRecycledFromPreviousBatch(queueState, item);\n    }\n    updateState(state => {\n      state.items[item.id] = item;\n    });\n  };\n  const handleItemProgress = (item, completed, loaded, total) => {\n    if (state.items[item.id]) {\n      updateState(state => {\n        const stateItem = state.items[item.id];\n        stateItem.loaded = loaded;\n        stateItem.completed = completed;\n        stateItem.total = total;\n      });\n      trigger(UPLOADER_EVENTS.ITEM_PROGRESS, getState().items[item.id]);\n    }\n  };\n  sender.on(SENDER_EVENTS.ITEM_PROGRESS, handleItemProgress);\n  sender.on(SENDER_EVENTS.BATCH_PROGRESS, batch => {\n    const batchItems = state.batches[batch.id]?.batch.items;\n    if (batchItems) {\n      const [loaded, total] = batchItems.reduce((res, {\n        id\n      }) => {\n        const {\n          loaded,\n          file\n        } = state.items[id];\n        const size = file?.size || loaded || 1;\n        res[0] += loaded;\n        res[1] += size;\n        return res;\n      }, [0, 0]);\n      updateState(state => {\n        const stateBatch = state.batches[batch.id].batch;\n        stateBatch.total = total;\n        stateBatch.loaded = loaded;\n        stateBatch.completed = loaded / total;\n      });\n      triggerUploaderBatchEvent(queueState, batch.id, UPLOADER_EVENTS.BATCH_PROGRESS);\n    }\n  });\n  const queueState = {\n    uploaderId,\n    getOptions: () => options,\n    getCurrentActiveCount: () => state.activeIds.length,\n    getState,\n    updateState,\n    trigger,\n    runCancellable: (name, ...args) => {\n      if (!isFunction(cancellable)) {\n        throw new Error(\"Uploader queue - cancellable is of wrong type\");\n      }\n      return cancellable(name, ...args);\n    },\n    sender,\n    handleItemProgress,\n    clearAllUploads: () => {\n      queueState.updateState(state => {\n        state.itemQueue = {};\n        state.batchQueue = [];\n        state.currentBatch = null;\n        state.batches = {};\n        state.items = {};\n        state.activeIds = [];\n      });\n    },\n    clearBatchUploads: batchId => {\n      scheduleIdleWork(() => {\n        logger.debugLog(`uploader.queue: started scheduled work to clear batch uploads (${batchId})`);\n        if (getState().batches[batchId]) {\n          clearBatchData(queueState, batchId);\n        }\n      });\n    }\n  };\n  if (hasWindow() && logger.isDebugOn()) {\n    window[`__rpldy_${uploaderId}_queue_state`] = queueState;\n  }\n  return {\n    updateState,\n    getState: queueState.getState,\n    runCancellable: queueState.runCancellable,\n    uploadBatch: (batch, batchOptions) => {\n      if (batchOptions) {\n        updateState(state => {\n          state.batches[batch.id].batchOptions = batchOptions;\n        });\n      }\n      processQueueNext(queueState);\n    },\n    addBatch: (batch, batchOptions) => {\n      updateState(state => {\n        state.batches[batch.id] = {\n          batch,\n          batchOptions,\n          finishedCounter: 0\n        };\n        state.batchQueue.push(batch.id);\n        state.itemQueue[batch.id] = batch.items.map(({\n          id\n        }) => id);\n      });\n      batch.items.forEach(add);\n      return getBatchFromState(state, batch.id);\n    },\n    abortItem: (...args) => processAbortItem(queueState, ...args),\n    abortBatch: (...args) => processAbortBatch(queueState, ...args),\n    abortAll: (...args) => processAbortAll(queueState, ...args),\n    clearPendingBatches: () => {\n      removePendingBatches(queueState);\n    },\n    uploadPendingBatches: uploadOptions => {\n      preparePendingForUpload(queueState, uploadOptions);\n      processQueueNext(queueState);\n    },\n    cancelBatch: batch => cancelBatchWithId(queueState, batch.id)\n  };\n};\nexport default createUploaderQueue;","map":{"version":3,"names":["logger","hasWindow","isFunction","scheduleIdleWork","createState","SENDER_EVENTS","UPLOADER_EVENTS","processQueueNext","processAbortItem","processAbortBatch","processAbortAll","detachRecycledFromPreviousBatch","getBatchFromState","preparePendingForUpload","removePendingBatches","clearBatchData","cancelBatchWithId","triggerUploaderBatchEvent","createUploaderQueue","options","trigger","cancellable","sender","uploaderId","state","update","itemQueue","batchQueue","currentBatch","batchesStartPending","batches","items","activeIds","aborts","getState","updateState","updater","add","item","id","recycled","Error","queueState","handleItemProgress","completed","loaded","total","stateItem","ITEM_PROGRESS","on","BATCH_PROGRESS","batch","batchItems","reduce","res","file","size","stateBatch","getOptions","getCurrentActiveCount","length","runCancellable","name","args","clearAllUploads","clearBatchUploads","batchId","debugLog","isDebugOn","window","uploadBatch","batchOptions","addBatch","finishedCounter","push","map","forEach","abortItem","abortBatch","abortAll","clearPendingBatches","uploadPendingBatches","uploadOptions","cancelBatch"],"sources":["C:/Users/y2006/OneDrive/바탕 화면/poba/poba/node_modules/@rpldy/uploader/lib/esm/queue/uploaderQueue.js"],"sourcesContent":["import { logger, hasWindow, isFunction, scheduleIdleWork } from \"@rpldy/shared\";\nimport createState from \"@rpldy/simple-state\";\nimport { SENDER_EVENTS, UPLOADER_EVENTS } from \"../consts\";\nimport processQueueNext from \"./processQueueNext\";\nimport { processAbortItem, processAbortBatch, processAbortAll } from \"./processAbort\";\nimport { detachRecycledFromPreviousBatch, getBatchFromState, preparePendingForUpload, removePendingBatches, clearBatchData, cancelBatchWithId, triggerUploaderBatchEvent } from \"./batchHelpers\";\nconst createUploaderQueue = (options, trigger, cancellable, sender, uploaderId) => {\n  const {\n    state,\n    update\n  } = createState({\n    itemQueue: {},\n    batchQueue: [],\n    currentBatch: null,\n    batchesStartPending: [],\n    batches: {},\n    items: {},\n    activeIds: [],\n    aborts: {}\n  });\n  const getState = () => state;\n  const updateState = updater => {\n    update(updater);\n  };\n  const add = item => {\n    if (state.items[item.id] && !item.recycled) {\n      throw new Error(`Uploader queue conflict - item ${item.id} already exists`);\n    }\n    if (item.recycled) {\n      detachRecycledFromPreviousBatch(queueState, item);\n    }\n    updateState(state => {\n      state.items[item.id] = item;\n    });\n  };\n  const handleItemProgress = (item, completed, loaded, total) => {\n    if (state.items[item.id]) {\n      updateState(state => {\n        const stateItem = state.items[item.id];\n        stateItem.loaded = loaded;\n        stateItem.completed = completed;\n        stateItem.total = total;\n      });\n      trigger(UPLOADER_EVENTS.ITEM_PROGRESS, getState().items[item.id]);\n    }\n  };\n  sender.on(SENDER_EVENTS.ITEM_PROGRESS, handleItemProgress);\n  sender.on(SENDER_EVENTS.BATCH_PROGRESS, batch => {\n    const batchItems = state.batches[batch.id]?.batch.items;\n    if (batchItems) {\n      const [loaded, total] = batchItems.reduce((res, {\n        id\n      }) => {\n        const {\n          loaded,\n          file\n        } = state.items[id];\n        const size = file?.size || loaded || 1;\n        res[0] += loaded;\n        res[1] += size;\n        return res;\n      }, [0, 0]);\n      updateState(state => {\n        const stateBatch = state.batches[batch.id].batch;\n        stateBatch.total = total;\n        stateBatch.loaded = loaded;\n        stateBatch.completed = loaded / total;\n      });\n      triggerUploaderBatchEvent(queueState, batch.id, UPLOADER_EVENTS.BATCH_PROGRESS);\n    }\n  });\n  const queueState = {\n    uploaderId,\n    getOptions: () => options,\n    getCurrentActiveCount: () => state.activeIds.length,\n    getState,\n    updateState,\n    trigger,\n    runCancellable: (name, ...args) => {\n      if (!isFunction(cancellable)) {\n        throw new Error(\"Uploader queue - cancellable is of wrong type\");\n      }\n      return cancellable(name, ...args);\n    },\n    sender,\n    handleItemProgress,\n    clearAllUploads: () => {\n      queueState.updateState(state => {\n        state.itemQueue = {};\n        state.batchQueue = [];\n        state.currentBatch = null;\n        state.batches = {};\n        state.items = {};\n        state.activeIds = [];\n      });\n    },\n    clearBatchUploads: batchId => {\n      scheduleIdleWork(() => {\n        logger.debugLog(`uploader.queue: started scheduled work to clear batch uploads (${batchId})`);\n        if (getState().batches[batchId]) {\n          clearBatchData(queueState, batchId);\n        }\n      });\n    }\n  };\n  if (hasWindow() && logger.isDebugOn()) {\n    window[`__rpldy_${uploaderId}_queue_state`] = queueState;\n  }\n  return {\n    updateState,\n    getState: queueState.getState,\n    runCancellable: queueState.runCancellable,\n    uploadBatch: (batch, batchOptions) => {\n      if (batchOptions) {\n        updateState(state => {\n          state.batches[batch.id].batchOptions = batchOptions;\n        });\n      }\n      processQueueNext(queueState);\n    },\n    addBatch: (batch, batchOptions) => {\n      updateState(state => {\n        state.batches[batch.id] = {\n          batch,\n          batchOptions,\n          finishedCounter: 0\n        };\n        state.batchQueue.push(batch.id);\n        state.itemQueue[batch.id] = batch.items.map(({\n          id\n        }) => id);\n      });\n      batch.items.forEach(add);\n      return getBatchFromState(state, batch.id);\n    },\n    abortItem: (...args) => processAbortItem(queueState, ...args),\n    abortBatch: (...args) => processAbortBatch(queueState, ...args),\n    abortAll: (...args) => processAbortAll(queueState, ...args),\n    clearPendingBatches: () => {\n      removePendingBatches(queueState);\n    },\n    uploadPendingBatches: uploadOptions => {\n      preparePendingForUpload(queueState, uploadOptions);\n      processQueueNext(queueState);\n    },\n    cancelBatch: batch => cancelBatchWithId(queueState, batch.id)\n  };\n};\nexport default createUploaderQueue;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}