{"ast":null,"code":"import { clone, getMerge, isProduction } from \"@rpldy/shared\";\nimport { PROXY_SYM, STATE_SYM } from \"./consts\";\nimport { isProxiable, isProxy } from \"./utils\";\nconst mergeWithSymbols = getMerge({\n  withSymbols: true,\n  predicate: key => key !== PROXY_SYM && key !== STATE_SYM\n});\nconst getIsUpdateable = proxy => isProduction() ? true : proxy[STATE_SYM].isUpdateable;\nconst setIsUpdateable = (proxy, value) => {\n  if (!isProduction()) {\n    proxy[STATE_SYM].isUpdateable = value;\n  }\n};\nconst deepProxy = (obj, traps) => {\n  let proxy;\n  if (isProxiable(obj)) {\n    if (!isProxy(obj)) {\n      obj[PROXY_SYM] = true;\n      proxy = new Proxy(obj, traps);\n    }\n    Object.keys(obj).forEach(key => {\n      obj[key] = deepProxy(obj[key], traps);\n    });\n  }\n  return proxy || obj;\n};\nconst unwrapProxy = proxy => isProxy(proxy) ? clone(proxy, mergeWithSymbols) : proxy;\nconst createState = obj => {\n  const traps = {\n    set: (obj, key, value) => {\n      if (getIsUpdateable(proxy)) {\n        obj[key] = deepProxy(value, traps);\n      }\n      return true;\n    },\n    get: (obj, key) => {\n      return key === PROXY_SYM ? unwrapProxy(obj) : obj[key];\n    },\n    defineProperty: () => {\n      throw new Error(\"Simple State doesnt support defining property\");\n    },\n    setPrototypeOf: () => {\n      throw new Error(\"Simple State doesnt support setting prototype\");\n    },\n    deleteProperty: (obj, key) => {\n      if (getIsUpdateable(proxy)) {\n        delete obj[key];\n      }\n      return true;\n    }\n  };\n  if (!isProduction() && !isProxy(obj)) {\n    Object.defineProperty(obj, STATE_SYM, {\n      value: {\n        isUpdateable: false\n      },\n      configurable: true\n    });\n  }\n  const proxy = !isProduction() ? deepProxy(obj, traps) : obj;\n  return {\n    state: proxy,\n    update: fn => {\n      if (!isProduction() && getIsUpdateable(proxy)) {\n        throw new Error(\"Can't call update on State already being updated!\");\n      }\n      try {\n        setIsUpdateable(proxy, true);\n        fn(proxy);\n      } finally {\n        setIsUpdateable(proxy, false);\n      }\n      return proxy;\n    },\n    unwrap: entry => entry ? unwrapProxy(entry) : isProxy(proxy) ? unwrapProxy(proxy) : proxy\n  };\n};\nexport default createState;\nexport { isProxy, unwrapProxy as unwrap };","map":{"version":3,"names":["clone","getMerge","isProduction","PROXY_SYM","STATE_SYM","isProxiable","isProxy","mergeWithSymbols","withSymbols","predicate","key","getIsUpdateable","proxy","isUpdateable","setIsUpdateable","value","deepProxy","obj","traps","Proxy","Object","keys","forEach","unwrapProxy","createState","set","get","defineProperty","Error","setPrototypeOf","deleteProperty","configurable","state","update","fn","unwrap","entry"],"sources":["C:/Users/y2006/OneDrive/바탕 화면/poba/poba/node_modules/@rpldy/simple-state/lib/esm/createState.js"],"sourcesContent":["import { clone, getMerge, isProduction } from \"@rpldy/shared\";\nimport { PROXY_SYM, STATE_SYM } from \"./consts\";\nimport { isProxiable, isProxy } from \"./utils\";\nconst mergeWithSymbols = getMerge({\n  withSymbols: true,\n  predicate: key => key !== PROXY_SYM && key !== STATE_SYM\n});\nconst getIsUpdateable = proxy => isProduction() ? true : proxy[STATE_SYM].isUpdateable;\nconst setIsUpdateable = (proxy, value) => {\n  if (!isProduction()) {\n    proxy[STATE_SYM].isUpdateable = value;\n  }\n};\nconst deepProxy = (obj, traps) => {\n  let proxy;\n  if (isProxiable(obj)) {\n    if (!isProxy(obj)) {\n      obj[PROXY_SYM] = true;\n      proxy = new Proxy(obj, traps);\n    }\n    Object.keys(obj).forEach(key => {\n      obj[key] = deepProxy(obj[key], traps);\n    });\n  }\n  return proxy || obj;\n};\nconst unwrapProxy = proxy => isProxy(proxy) ? clone(proxy, mergeWithSymbols) : proxy;\nconst createState = obj => {\n  const traps = {\n    set: (obj, key, value) => {\n      if (getIsUpdateable(proxy)) {\n        obj[key] = deepProxy(value, traps);\n      }\n      return true;\n    },\n    get: (obj, key) => {\n      return key === PROXY_SYM ? unwrapProxy(obj) : obj[key];\n    },\n    defineProperty: () => {\n      throw new Error(\"Simple State doesnt support defining property\");\n    },\n    setPrototypeOf: () => {\n      throw new Error(\"Simple State doesnt support setting prototype\");\n    },\n    deleteProperty: (obj, key) => {\n      if (getIsUpdateable(proxy)) {\n        delete obj[key];\n      }\n      return true;\n    }\n  };\n  if (!isProduction() && !isProxy(obj)) {\n    Object.defineProperty(obj, STATE_SYM, {\n      value: {\n        isUpdateable: false\n      },\n      configurable: true\n    });\n  }\n  const proxy = !isProduction() ? deepProxy(obj, traps) : obj;\n  return {\n    state: proxy,\n    update: fn => {\n      if (!isProduction() && getIsUpdateable(proxy)) {\n        throw new Error(\"Can't call update on State already being updated!\");\n      }\n      try {\n        setIsUpdateable(proxy, true);\n        fn(proxy);\n      } finally {\n        setIsUpdateable(proxy, false);\n      }\n      return proxy;\n    },\n    unwrap: entry => entry ? unwrapProxy(entry) : isProxy(proxy) ? unwrapProxy(proxy) : proxy\n  };\n};\nexport default createState;\nexport { isProxy, unwrapProxy as unwrap };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}