{"ast":null,"code":"import { logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"./consts\";\nimport createUploadQueue from \"./queue\";\nimport createItemsSender from \"./batchItemsSender\";\nimport createBatch from \"./batch\";\nconst createProcessor = (trigger, cancellable, options, uploaderId) => {\n  const sender = createItemsSender(),\n    queue = createUploadQueue(options, trigger, cancellable, sender, uploaderId);\n  return {\n    abortBatch: batchId => {\n      queue.abortBatch(batchId);\n    },\n    abort: id => {\n      if (id) {\n        queue.abortItem(id);\n      } else {\n        queue.abortAll();\n      }\n    },\n    addNewBatch: (files, processOptions) => createBatch(files, uploaderId, processOptions).then(batch => {\n      let resultP;\n      if (batch.items.length) {\n        const addedBatch = queue.addBatch(batch, processOptions);\n        resultP = queue.runCancellable(UPLOADER_EVENTS.BATCH_ADD, addedBatch, processOptions).then(isCancelled => {\n          if (!isCancelled) {\n            logger.debugLog(`uploady.uploader [${uploaderId}]: new items added - auto upload =\n                       ${String(processOptions.autoUpload)}`, addedBatch.items);\n            if (processOptions.autoUpload) {\n              queue.uploadBatch(addedBatch);\n            }\n          } else {\n            queue.cancelBatch(addedBatch);\n          }\n          return addedBatch;\n        });\n      } else {\n        logger.debugLog(`uploady.uploader: no items to add. batch ${batch.id} is empty. check fileFilter if this isn't intended`);\n      }\n      return resultP || Promise.resolve(null);\n    }),\n    clearPendingBatches: () => {\n      queue.clearPendingBatches();\n    },\n    processPendingBatches: uploadOptions => {\n      queue.uploadPendingBatches(uploadOptions);\n    }\n  };\n};\nexport default createProcessor;","map":{"version":3,"names":["logger","UPLOADER_EVENTS","createUploadQueue","createItemsSender","createBatch","createProcessor","trigger","cancellable","options","uploaderId","sender","queue","abortBatch","batchId","abort","id","abortItem","abortAll","addNewBatch","files","processOptions","then","batch","resultP","items","length","addedBatch","addBatch","runCancellable","BATCH_ADD","isCancelled","debugLog","String","autoUpload","uploadBatch","cancelBatch","Promise","resolve","clearPendingBatches","processPendingBatches","uploadOptions","uploadPendingBatches"],"sources":["C:/Users/y2006/OneDrive/바탕 화면/poba/poba/node_modules/@rpldy/uploader/lib/esm/processor.js"],"sourcesContent":["import { logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"./consts\";\nimport createUploadQueue from \"./queue\";\nimport createItemsSender from \"./batchItemsSender\";\nimport createBatch from \"./batch\";\nconst createProcessor = (trigger, cancellable, options, uploaderId) => {\n  const sender = createItemsSender(),\n    queue = createUploadQueue(options, trigger, cancellable, sender, uploaderId);\n  return {\n    abortBatch: batchId => {\n      queue.abortBatch(batchId);\n    },\n    abort: id => {\n      if (id) {\n        queue.abortItem(id);\n      } else {\n        queue.abortAll();\n      }\n    },\n    addNewBatch: (files, processOptions) => createBatch(files, uploaderId, processOptions).then(batch => {\n      let resultP;\n      if (batch.items.length) {\n        const addedBatch = queue.addBatch(batch, processOptions);\n        resultP = queue.runCancellable(UPLOADER_EVENTS.BATCH_ADD, addedBatch, processOptions).then(isCancelled => {\n          if (!isCancelled) {\n            logger.debugLog(`uploady.uploader [${uploaderId}]: new items added - auto upload =\n                       ${String(processOptions.autoUpload)}`, addedBatch.items);\n            if (processOptions.autoUpload) {\n              queue.uploadBatch(addedBatch);\n            }\n          } else {\n            queue.cancelBatch(addedBatch);\n          }\n          return addedBatch;\n        });\n      } else {\n        logger.debugLog(`uploady.uploader: no items to add. batch ${batch.id} is empty. check fileFilter if this isn't intended`);\n      }\n      return resultP || Promise.resolve(null);\n    }),\n    clearPendingBatches: () => {\n      queue.clearPendingBatches();\n    },\n    processPendingBatches: uploadOptions => {\n      queue.uploadPendingBatches(uploadOptions);\n    }\n  };\n};\nexport default createProcessor;"],"mappings":"AAAA,SAASA,MAAM,QAAQ,eAAe;AACtC,SAASC,eAAe,QAAQ,UAAU;AAC1C,OAAOC,iBAAiB,MAAM,SAAS;AACvC,OAAOC,iBAAiB,MAAM,oBAAoB;AAClD,OAAOC,WAAW,MAAM,SAAS;AACjC,MAAMC,eAAe,GAAGA,CAACC,OAAO,EAAEC,WAAW,EAAEC,OAAO,EAAEC,UAAU,KAAK;EACrE,MAAMC,MAAM,GAAGP,iBAAiB,CAAC,CAAC;IAChCQ,KAAK,GAAGT,iBAAiB,CAACM,OAAO,EAAEF,OAAO,EAAEC,WAAW,EAAEG,MAAM,EAAED,UAAU,CAAC;EAC9E,OAAO;IACLG,UAAU,EAAEC,OAAO,IAAI;MACrBF,KAAK,CAACC,UAAU,CAACC,OAAO,CAAC;IAC3B,CAAC;IACDC,KAAK,EAAEC,EAAE,IAAI;MACX,IAAIA,EAAE,EAAE;QACNJ,KAAK,CAACK,SAAS,CAACD,EAAE,CAAC;MACrB,CAAC,MAAM;QACLJ,KAAK,CAACM,QAAQ,CAAC,CAAC;MAClB;IACF,CAAC;IACDC,WAAW,EAAEA,CAACC,KAAK,EAAEC,cAAc,KAAKhB,WAAW,CAACe,KAAK,EAAEV,UAAU,EAAEW,cAAc,CAAC,CAACC,IAAI,CAACC,KAAK,IAAI;MACnG,IAAIC,OAAO;MACX,IAAID,KAAK,CAACE,KAAK,CAACC,MAAM,EAAE;QACtB,MAAMC,UAAU,GAAGf,KAAK,CAACgB,QAAQ,CAACL,KAAK,EAAEF,cAAc,CAAC;QACxDG,OAAO,GAAGZ,KAAK,CAACiB,cAAc,CAAC3B,eAAe,CAAC4B,SAAS,EAAEH,UAAU,EAAEN,cAAc,CAAC,CAACC,IAAI,CAACS,WAAW,IAAI;UACxG,IAAI,CAACA,WAAW,EAAE;YAChB9B,MAAM,CAAC+B,QAAQ,CAAC,qBAAqBtB,UAAU;AAC3D,yBAAyBuB,MAAM,CAACZ,cAAc,CAACa,UAAU,CAAC,EAAE,EAAEP,UAAU,CAACF,KAAK,CAAC;YACnE,IAAIJ,cAAc,CAACa,UAAU,EAAE;cAC7BtB,KAAK,CAACuB,WAAW,CAACR,UAAU,CAAC;YAC/B;UACF,CAAC,MAAM;YACLf,KAAK,CAACwB,WAAW,CAACT,UAAU,CAAC;UAC/B;UACA,OAAOA,UAAU;QACnB,CAAC,CAAC;MACJ,CAAC,MAAM;QACL1B,MAAM,CAAC+B,QAAQ,CAAC,4CAA4CT,KAAK,CAACP,EAAE,oDAAoD,CAAC;MAC3H;MACA,OAAOQ,OAAO,IAAIa,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;IACzC,CAAC,CAAC;IACFC,mBAAmB,EAAEA,CAAA,KAAM;MACzB3B,KAAK,CAAC2B,mBAAmB,CAAC,CAAC;IAC7B,CAAC;IACDC,qBAAqB,EAAEC,aAAa,IAAI;MACtC7B,KAAK,CAAC8B,oBAAoB,CAACD,aAAa,CAAC;IAC3C;EACF,CAAC;AACH,CAAC;AACD,eAAenC,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}