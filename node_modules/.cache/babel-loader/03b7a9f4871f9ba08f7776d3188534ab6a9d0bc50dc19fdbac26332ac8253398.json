{"ast":null,"code":"import { FILE_STATES, logger } from \"@rpldy/shared\";\nimport processBatchItems from \"./processBatchItems\";\nimport { getIsBatchReady, isNewBatchStarting, cancelBatchForItem, loadNewBatchForItem, failBatchForItem, isItemBatchStartPending } from \"./batchHelpers\";\nconst getIsItemInActiveRequest = (queue, itemId) => {\n  return queue.getState().activeIds.flat().includes(itemId);\n};\nconst getIsItemReady = item => item.state === FILE_STATES.ADDED;\nexport const findNextItemIndex = queue => {\n  const state = queue.getState(),\n    itemQueue = state.itemQueue,\n    items = state.items;\n  let nextItemId = null,\n    batchIndex = 0,\n    itemIndex = 0,\n    batchId = state.batchQueue[batchIndex];\n  while (batchId && !nextItemId) {\n    if (getIsBatchReady(queue, batchId)) {\n      nextItemId = itemQueue[batchId][itemIndex];\n      while (nextItemId && (getIsItemInActiveRequest(queue, nextItemId) || !getIsItemReady(items[nextItemId]))) {\n        itemIndex += 1;\n        nextItemId = itemQueue[batchId][itemIndex];\n      }\n    }\n    if (!nextItemId) {\n      batchIndex += 1;\n      batchId = state.batchQueue[batchIndex];\n      itemIndex = 0;\n    }\n  }\n  return nextItemId ? [batchId, itemIndex] : null;\n};\nexport const getNextIdGroup = queue => {\n  const state = queue.getState(),\n    itemQueue = state.itemQueue,\n    [nextBatchId, nextItemIndex] = findNextItemIndex(queue) || [];\n  let nextId = nextBatchId && ~nextItemIndex ? itemQueue[nextBatchId][nextItemIndex] : null,\n    nextGroup;\n  if (nextId) {\n    const {\n        batchOptions\n      } = state.batches[nextBatchId],\n      groupMax = batchOptions.maxGroupSize || 0;\n    if (batchOptions.grouped && groupMax > 1) {\n      const batchItems = state.itemQueue[nextBatchId];\n      nextGroup = batchItems.slice(nextItemIndex, nextItemIndex + groupMax);\n    } else {\n      nextGroup = [nextId];\n    }\n  }\n  return nextGroup;\n};\nconst updateItemsAsActive = (queue, ids) => {\n  queue.updateState(state => {\n    state.activeIds = state.activeIds.concat(ids);\n  });\n};\nconst processNextWithBatch = (queue, ids) => {\n  let newBatchP;\n  if (!isItemBatchStartPending(queue, ids[0])) {\n    updateItemsAsActive(queue, ids);\n    if (isNewBatchStarting(queue, ids[0])) {\n      newBatchP = loadNewBatchForItem(queue, ids[0]).then(allowBatch => {\n        let cancelled = !allowBatch;\n        if (cancelled) {\n          cancelBatchForItem(queue, ids[0]);\n          processNext(queue);\n        }\n        return cancelled;\n      }).catch(err => {\n        logger.debugLog(\"uploader.processor: encountered error while preparing batch for request\", err);\n        failBatchForItem(queue, ids[0], err);\n        processNext(queue);\n        return true;\n      });\n    } else {\n      newBatchP = Promise.resolve(false);\n    }\n  } else {\n    newBatchP = Promise.resolve(true);\n  }\n  return newBatchP;\n};\nconst processNext = queue => {\n  let processPromise;\n  const ids = getNextIdGroup(queue);\n  if (ids) {\n    const currentCount = queue.getCurrentActiveCount(),\n      {\n        concurrent = !!0,\n        maxConcurrent = 0\n      } = queue.getOptions();\n    if (!currentCount || concurrent && currentCount < maxConcurrent) {\n      logger.debugLog(\"uploader.processor: Processing next upload - \", {\n        ids,\n        currentCount\n      });\n      processPromise = processNextWithBatch(queue, ids).then(failedOrCancelled => {\n        if (!failedOrCancelled) {\n          processBatchItems(queue, ids, processNext);\n          if (concurrent) {\n            processNext(queue);\n          }\n        }\n      });\n    }\n  }\n  return processPromise;\n};\nexport default processNext;","map":{"version":3,"names":["FILE_STATES","logger","processBatchItems","getIsBatchReady","isNewBatchStarting","cancelBatchForItem","loadNewBatchForItem","failBatchForItem","isItemBatchStartPending","getIsItemInActiveRequest","queue","itemId","getState","activeIds","flat","includes","getIsItemReady","item","state","ADDED","findNextItemIndex","itemQueue","items","nextItemId","batchIndex","itemIndex","batchId","batchQueue","getNextIdGroup","nextBatchId","nextItemIndex","nextId","nextGroup","batchOptions","batches","groupMax","maxGroupSize","grouped","batchItems","slice","updateItemsAsActive","ids","updateState","concat","processNextWithBatch","newBatchP","then","allowBatch","cancelled","processNext","catch","err","debugLog","Promise","resolve","processPromise","currentCount","getCurrentActiveCount","concurrent","maxConcurrent","getOptions","failedOrCancelled"],"sources":["C:/Users/y2006/OneDrive/바탕 화면/poba/poba/node_modules/@rpldy/uploader/lib/esm/queue/processQueueNext.js"],"sourcesContent":["import { FILE_STATES, logger } from \"@rpldy/shared\";\nimport processBatchItems from \"./processBatchItems\";\nimport { getIsBatchReady, isNewBatchStarting, cancelBatchForItem, loadNewBatchForItem, failBatchForItem, isItemBatchStartPending } from \"./batchHelpers\";\nconst getIsItemInActiveRequest = (queue, itemId) => {\n  return queue.getState().activeIds.flat().includes(itemId);\n};\nconst getIsItemReady = item => item.state === FILE_STATES.ADDED;\nexport const findNextItemIndex = queue => {\n  const state = queue.getState(),\n    itemQueue = state.itemQueue,\n    items = state.items;\n  let nextItemId = null,\n    batchIndex = 0,\n    itemIndex = 0,\n    batchId = state.batchQueue[batchIndex];\n  while (batchId && !nextItemId) {\n    if (getIsBatchReady(queue, batchId)) {\n      nextItemId = itemQueue[batchId][itemIndex];\n      while (nextItemId && (getIsItemInActiveRequest(queue, nextItemId) || !getIsItemReady(items[nextItemId]))) {\n        itemIndex += 1;\n        nextItemId = itemQueue[batchId][itemIndex];\n      }\n    }\n    if (!nextItemId) {\n      batchIndex += 1;\n      batchId = state.batchQueue[batchIndex];\n      itemIndex = 0;\n    }\n  }\n  return nextItemId ? [batchId, itemIndex] : null;\n};\nexport const getNextIdGroup = queue => {\n  const state = queue.getState(),\n    itemQueue = state.itemQueue,\n    [nextBatchId, nextItemIndex] = findNextItemIndex(queue) || [];\n  let nextId = nextBatchId && ~nextItemIndex ? itemQueue[nextBatchId][nextItemIndex] : null,\n    nextGroup;\n  if (nextId) {\n    const {\n        batchOptions\n      } = state.batches[nextBatchId],\n      groupMax = batchOptions.maxGroupSize || 0;\n    if (batchOptions.grouped && groupMax > 1) {\n      const batchItems = state.itemQueue[nextBatchId];\n      nextGroup = batchItems.slice(nextItemIndex, nextItemIndex + groupMax);\n    } else {\n      nextGroup = [nextId];\n    }\n  }\n  return nextGroup;\n};\nconst updateItemsAsActive = (queue, ids) => {\n  queue.updateState(state => {\n    state.activeIds = state.activeIds.concat(ids);\n  });\n};\nconst processNextWithBatch = (queue, ids) => {\n  let newBatchP;\n  if (!isItemBatchStartPending(queue, ids[0])) {\n    updateItemsAsActive(queue, ids);\n    if (isNewBatchStarting(queue, ids[0])) {\n      newBatchP = loadNewBatchForItem(queue, ids[0]).then(allowBatch => {\n        let cancelled = !allowBatch;\n        if (cancelled) {\n          cancelBatchForItem(queue, ids[0]);\n          processNext(queue);\n        }\n        return cancelled;\n      }).catch(err => {\n        logger.debugLog(\"uploader.processor: encountered error while preparing batch for request\", err);\n        failBatchForItem(queue, ids[0], err);\n        processNext(queue);\n        return true;\n      });\n    } else {\n      newBatchP = Promise.resolve(false);\n    }\n  } else {\n    newBatchP = Promise.resolve(true);\n  }\n  return newBatchP;\n};\nconst processNext = queue => {\n  let processPromise;\n  const ids = getNextIdGroup(queue);\n  if (ids) {\n    const currentCount = queue.getCurrentActiveCount(),\n      {\n        concurrent = !!0,\n        maxConcurrent = 0\n      } = queue.getOptions();\n    if (!currentCount || concurrent && currentCount < maxConcurrent) {\n      logger.debugLog(\"uploader.processor: Processing next upload - \", {\n        ids,\n        currentCount\n      });\n      processPromise = processNextWithBatch(queue, ids).then(failedOrCancelled => {\n        if (!failedOrCancelled) {\n          processBatchItems(queue, ids, processNext);\n          if (concurrent) {\n            processNext(queue);\n          }\n        }\n      });\n    }\n  }\n  return processPromise;\n};\nexport default processNext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}