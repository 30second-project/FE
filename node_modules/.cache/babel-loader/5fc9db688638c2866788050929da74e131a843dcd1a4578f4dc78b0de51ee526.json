{"ast":null,"code":"import { FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport processFinishedRequest from \"./processFinishedRequest\";\nimport { getItemsPrepareUpdater } from \"./preSendPrepare\";\nimport { getIsItemFinalized } from \"./itemHelpers\";\nimport { getBatchDataFromItemId } from \"./batchHelpers\";\nconst preparePreRequestItems = getItemsPrepareUpdater(UPLOADER_EVENTS.REQUEST_PRE_SEND, items => items, (items, options) => ({\n  items,\n  options\n}));\nconst updateUploadingState = (queue, items, sendResult) => {\n  queue.updateState(state => {\n    items.forEach(bi => {\n      const item = state.items[bi.id];\n      item.state = FILE_STATES.UPLOADING;\n      state.aborts[bi.id] = sendResult.abort;\n    });\n  });\n};\nconst sendAllowedItems = (queue, itemsSendData, next) => {\n  const {\n    items,\n    options\n  } = itemsSendData;\n  const batch = queue.getState().batches[items[0].batchId]?.batch;\n  if (batch) {\n    let sendResult;\n    try {\n      sendResult = queue.sender.send(items, batch, options);\n    } catch (ex) {\n      logger.debugLog(`uploader.queue: sender failed with unexpected error`, ex);\n      sendResult = {\n        request: Promise.resolve({\n          status: 0,\n          state: FILE_STATES.ERROR,\n          response: ex.message\n        }),\n        abort: () => false,\n        senderType: \"exception-handler\"\n      };\n    }\n    const {\n      request\n    } = sendResult;\n    updateUploadingState(queue, items, sendResult);\n    request.then(requestInfo => {\n      const finishedData = items.map(item => ({\n        id: item.id,\n        info: requestInfo\n      }));\n      processFinishedRequest(queue, finishedData, next);\n    });\n  }\n};\nconst reportCancelledItems = (queue, items, cancelledResults, next) => {\n  const cancelledItemsIds = cancelledResults.map((isCancelled, index) => isCancelled ? items[index].id : null).filter(Boolean);\n  if (cancelledItemsIds.length) {\n    const finishedData = cancelledItemsIds.map(id => ({\n      id,\n      info: {\n        status: 0,\n        state: FILE_STATES.CANCELLED,\n        response: \"cancel\"\n      }\n    }));\n    processFinishedRequest(queue, finishedData, next);\n  }\n  return !!cancelledItemsIds.length;\n};\nconst reportPreparedError = (error, queue, items, next) => {\n  const finishedData = items.map(({\n    id\n  }) => ({\n    id,\n    info: {\n      status: 0,\n      state: FILE_STATES.ERROR,\n      response: error\n    }\n  }));\n  processFinishedRequest(queue, finishedData, next);\n};\nconst getAllowedItem = (id, queue) => {\n  const item = queue.getState().items[id];\n  return item && !getIsItemFinalized(item) ? item : undefined;\n};\nconst processAllowedItems = ({\n  allowedItems,\n  cancelledResults,\n  queue,\n  items,\n  ids,\n  next\n}) => {\n  const afterPreparePromise = allowedItems.length ? preparePreRequestItems(queue, allowedItems) : Promise.resolve();\n  let finalCancelledResults = cancelledResults;\n  return afterPreparePromise.catch(err => {\n    logger.debugLog(\"uploader.queue: encountered error while preparing items for request\", err);\n    reportPreparedError(err, queue, items, next);\n  }).then(itemsSendData => {\n    let nextP;\n    if (itemsSendData) {\n      if (itemsSendData.cancelled) {\n        finalCancelledResults = ids.map(() => true);\n      } else {\n        const hasAborted = itemsSendData.items.some(item => getIsItemFinalized(item));\n        if (!hasAborted) {\n          sendAllowedItems(queue, {\n            items: itemsSendData.items,\n            options: itemsSendData.options\n          }, next);\n        } else {\n          logger.debugLog(\"uploader.queue: send data contains aborted items - not sending\");\n        }\n      }\n    }\n    if (!reportCancelledItems(queue, items, finalCancelledResults, next)) {\n      nextP = next(queue);\n    }\n    return nextP;\n  });\n};\nconst processBatchItems = (queue, ids, next) => {\n  const state = queue.getState();\n  let items = Object.values(state.items);\n  items = items.filter(item => ids.includes(item.id) && !getIsItemFinalized(item));\n  return Promise.all(items.map(i => {\n    const {\n      batchOptions\n    } = getBatchDataFromItemId(queue, i.id);\n    return queue.runCancellable(UPLOADER_EVENTS.ITEM_START, i, batchOptions);\n  })).then(cancelledResults => {\n    let allowedItems = cancelledResults.map((isCancelled, index) => isCancelled ? null : getAllowedItem(items[index].id, queue)).filter(Boolean);\n    return {\n      allowedItems,\n      cancelledResults,\n      queue,\n      items,\n      ids,\n      next\n    };\n  }).then(processAllowedItems);\n};\nexport default processBatchItems;","map":{"version":3,"names":["FILE_STATES","logger","UPLOADER_EVENTS","processFinishedRequest","getItemsPrepareUpdater","getIsItemFinalized","getBatchDataFromItemId","preparePreRequestItems","REQUEST_PRE_SEND","items","options","updateUploadingState","queue","sendResult","updateState","state","forEach","bi","item","id","UPLOADING","aborts","abort","sendAllowedItems","itemsSendData","next","batch","getState","batches","batchId","sender","send","ex","debugLog","request","Promise","resolve","status","ERROR","response","message","senderType","then","requestInfo","finishedData","map","info","reportCancelledItems","cancelledResults","cancelledItemsIds","isCancelled","index","filter","Boolean","length","CANCELLED","reportPreparedError","error","getAllowedItem","undefined","processAllowedItems","allowedItems","ids","afterPreparePromise","finalCancelledResults","catch","err","nextP","cancelled","hasAborted","some","processBatchItems","Object","values","includes","all","i","batchOptions","runCancellable","ITEM_START"],"sources":["C:/Users/y2006/OneDrive/바탕 화면/poba/poba/node_modules/@rpldy/uploader/lib/esm/queue/processBatchItems.js"],"sourcesContent":["import { FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport processFinishedRequest from \"./processFinishedRequest\";\nimport { getItemsPrepareUpdater } from \"./preSendPrepare\";\nimport { getIsItemFinalized } from \"./itemHelpers\";\nimport { getBatchDataFromItemId } from \"./batchHelpers\";\nconst preparePreRequestItems = getItemsPrepareUpdater(UPLOADER_EVENTS.REQUEST_PRE_SEND, items => items, (items, options) => ({\n  items,\n  options\n}));\nconst updateUploadingState = (queue, items, sendResult) => {\n  queue.updateState(state => {\n    items.forEach(bi => {\n      const item = state.items[bi.id];\n      item.state = FILE_STATES.UPLOADING;\n      state.aborts[bi.id] = sendResult.abort;\n    });\n  });\n};\nconst sendAllowedItems = (queue, itemsSendData, next) => {\n  const {\n    items,\n    options\n  } = itemsSendData;\n  const batch = queue.getState().batches[items[0].batchId]?.batch;\n  if (batch) {\n    let sendResult;\n    try {\n      sendResult = queue.sender.send(items, batch, options);\n    } catch (ex) {\n      logger.debugLog(`uploader.queue: sender failed with unexpected error`, ex);\n      sendResult = {\n        request: Promise.resolve({\n          status: 0,\n          state: FILE_STATES.ERROR,\n          response: ex.message\n        }),\n        abort: () => false,\n        senderType: \"exception-handler\"\n      };\n    }\n    const {\n      request\n    } = sendResult;\n    updateUploadingState(queue, items, sendResult);\n    request.then(requestInfo => {\n      const finishedData = items.map(item => ({\n        id: item.id,\n        info: requestInfo\n      }));\n      processFinishedRequest(queue, finishedData, next);\n    });\n  }\n};\nconst reportCancelledItems = (queue, items, cancelledResults, next) => {\n  const cancelledItemsIds = cancelledResults.map((isCancelled, index) => isCancelled ? items[index].id : null).filter(Boolean);\n  if (cancelledItemsIds.length) {\n    const finishedData = cancelledItemsIds.map(id => ({\n      id,\n      info: {\n        status: 0,\n        state: FILE_STATES.CANCELLED,\n        response: \"cancel\"\n      }\n    }));\n    processFinishedRequest(queue, finishedData, next);\n  }\n  return !!cancelledItemsIds.length;\n};\nconst reportPreparedError = (error, queue, items, next) => {\n  const finishedData = items.map(({\n    id\n  }) => ({\n    id,\n    info: {\n      status: 0,\n      state: FILE_STATES.ERROR,\n      response: error\n    }\n  }));\n  processFinishedRequest(queue, finishedData, next);\n};\nconst getAllowedItem = (id, queue) => {\n  const item = queue.getState().items[id];\n  return item && !getIsItemFinalized(item) ? item : undefined;\n};\nconst processAllowedItems = ({\n  allowedItems,\n  cancelledResults,\n  queue,\n  items,\n  ids,\n  next\n}) => {\n  const afterPreparePromise = allowedItems.length ? preparePreRequestItems(queue, allowedItems) : Promise.resolve();\n  let finalCancelledResults = cancelledResults;\n  return afterPreparePromise.catch(err => {\n    logger.debugLog(\"uploader.queue: encountered error while preparing items for request\", err);\n    reportPreparedError(err, queue, items, next);\n  }).then(itemsSendData => {\n    let nextP;\n    if (itemsSendData) {\n      if (itemsSendData.cancelled) {\n        finalCancelledResults = ids.map(() => true);\n      } else {\n        const hasAborted = itemsSendData.items.some(item => getIsItemFinalized(item));\n        if (!hasAborted) {\n          sendAllowedItems(queue, {\n            items: itemsSendData.items,\n            options: itemsSendData.options\n          }, next);\n        } else {\n          logger.debugLog(\"uploader.queue: send data contains aborted items - not sending\");\n        }\n      }\n    }\n    if (!reportCancelledItems(queue, items, finalCancelledResults, next)) {\n      nextP = next(queue);\n    }\n    return nextP;\n  });\n};\nconst processBatchItems = (queue, ids, next) => {\n  const state = queue.getState();\n  let items = Object.values(state.items);\n  items = items.filter(item => ids.includes(item.id) && !getIsItemFinalized(item));\n  return Promise.all(items.map(i => {\n    const {\n      batchOptions\n    } = getBatchDataFromItemId(queue, i.id);\n    return queue.runCancellable(UPLOADER_EVENTS.ITEM_START, i, batchOptions);\n  })).then(cancelledResults => {\n    let allowedItems = cancelledResults.map((isCancelled, index) => isCancelled ? null : getAllowedItem(items[index].id, queue)).filter(Boolean);\n    return {\n      allowedItems,\n      cancelledResults,\n      queue,\n      items,\n      ids,\n      next\n    };\n  }).then(processAllowedItems);\n};\nexport default processBatchItems;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}