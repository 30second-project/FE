{"ast":null,"code":"import { BATCH_STATES, logger, merge, FILE_STATES, scheduleIdleWork } from \"@rpldy/shared\";\nimport { unwrap } from \"@rpldy/simple-state\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport { getItemsPrepareUpdater } from \"./preSendPrepare\";\nimport { finalizeItem, getIsItemExists } from \"./itemHelpers\";\nconst prepareBatchStartItems = getItemsPrepareUpdater(UPLOADER_EVENTS.BATCH_START, batch => batch.items, null, ({\n  batch\n} = {\n  batch: false\n}) => {\n  if (batch) {\n    throw new Error(`BATCH_START event handlers cannot update batch data. Only items & options`);\n  }\n});\nconst BATCH_READY_STATES = [BATCH_STATES.ADDED, BATCH_STATES.PROCESSING, BATCH_STATES.UPLOADING];\nconst BATCH_FINISHED_STATES = [BATCH_STATES.ABORTED, BATCH_STATES.CANCELLED, BATCH_STATES.FINISHED, BATCH_STATES.ERROR];\nconst getBatchFromState = (state, id) => state.batches[id].batch;\nconst getBatch = (queue, id) => {\n  return getBatchFromState(queue.getState(), id);\n};\nconst getBatchDataFromItemId = (queue, itemId) => {\n  const state = queue.getState();\n  const item = state.items[itemId];\n  return state.batches[item.batchId];\n};\nconst getBatchFromItemId = (queue, itemId) => {\n  return getBatchDataFromItemId(queue, itemId).batch;\n};\nconst removeBatchItems = (queue, batchId) => {\n  const batch = getBatch(queue, batchId);\n  batch.items.forEach(({\n    id\n  }) => finalizeItem(queue, id, true));\n};\nconst removeBatch = (queue, batchId) => {\n  queue.updateState(state => {\n    delete state.batches[batchId];\n    delete state.itemQueue[batchId];\n    const batchQueueIndex = state.batchQueue.indexOf(batchId);\n    if (~batchQueueIndex) {\n      state.batchQueue.splice(batchQueueIndex, 1);\n    }\n    const pendingFlagIndex = state.batchesStartPending.indexOf(batchId);\n    if (~pendingFlagIndex) {\n      state.batchesStartPending.splice(pendingFlagIndex, 1);\n    }\n  });\n};\nconst finalizeBatch = (queue, batchId, eventType, finalState = BATCH_STATES.FINISHED, additionalInfo) => {\n  queue.updateState(state => {\n    const batch = getBatchFromState(state, batchId);\n    batch.state = finalState;\n    if (additionalInfo) {\n      batch.additionalInfo = additionalInfo;\n    }\n  });\n  triggerUploaderBatchEvent(queue, batchId, eventType);\n  triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_FINALIZE);\n};\nconst cancelBatchWithId = (queue, batchId) => {\n  logger.debugLog(\"uploady.uploader.batchHelpers: cancelling batch: \", batchId);\n  finalizeBatch(queue, batchId, UPLOADER_EVENTS.BATCH_CANCEL, BATCH_STATES.CANCELLED);\n  removeBatchItems(queue, batchId);\n  removeBatch(queue, batchId);\n};\nconst cancelBatchForItem = (queue, itemId) => {\n  if (getIsItemExists(queue, itemId)) {\n    const data = getBatchDataFromItemId(queue, itemId),\n      batchId = data?.batch.id;\n    if (batchId) {\n      cancelBatchWithId(queue, batchId);\n    } else {\n      logger.debugLog(`uploady.uploader.batchHelpers: cancel batch called for batch already removed (item id = ${itemId})`);\n    }\n  }\n};\nconst failBatchForItem = (queue, itemId, err) => {\n  const batch = getBatchFromItemId(queue, itemId),\n    batchId = batch.id;\n  logger.debugLog(\"uploady.uploader.batchHelpers: failing batch: \", {\n    batch\n  });\n  finalizeBatch(queue, batchId, UPLOADER_EVENTS.BATCH_ERROR, BATCH_STATES.ERROR, err.message);\n  removeBatchItems(queue, batchId);\n  removeBatch(queue, batchId);\n};\nconst isItemBatchStartPending = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  return queue.getState().batchesStartPending.includes(batch.id);\n};\nconst isNewBatchStarting = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  return queue.getState().currentBatch !== batch.id;\n};\nconst loadNewBatchForItem = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  queue.updateState(state => {\n    state.batchesStartPending.push(batch.id);\n  });\n  return prepareBatchStartItems(queue, batch).then(({\n    cancelled\n  }) => {\n    let alreadyFinished = false;\n    queue.updateState(state => {\n      const pendingFlagIndex = state.batchesStartPending.indexOf(batch.id);\n      state.batchesStartPending.splice(pendingFlagIndex, 1);\n    });\n    if (!cancelled) {\n      alreadyFinished = !getIsItemExists(queue, itemId);\n      if (!alreadyFinished) {\n        queue.updateState(state => {\n          state.currentBatch = batch.id;\n        });\n      }\n    }\n    return !cancelled && !alreadyFinished;\n  });\n};\nconst cleanUpFinishedBatches = queue => {\n  scheduleIdleWork(() => {\n    const state = queue.getState();\n    Object.keys(state.batches).forEach(batchId => {\n      const {\n        batch,\n        finishedCounter\n      } = state.batches[batchId];\n      const {\n        orgItemCount\n      } = batch;\n      const alreadyFinalized = getIsBatchFinalized(batch);\n      if (orgItemCount === finishedCounter) {\n        if (!alreadyFinalized && batch.completed !== 100) {\n          queue.updateState(state => {\n            const batch = getBatchFromState(state, batchId);\n            batch.completed = 100;\n            batch.loaded = batch.items.reduce((res, {\n              loaded\n            }) => res + loaded, 0);\n          });\n          triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_PROGRESS);\n        }\n        queue.updateState(state => {\n          if (state.currentBatch === batchId) {\n            state.currentBatch = null;\n          }\n        });\n        logger.debugLog(`uploady.uploader.batchHelpers: cleaning up batch: ${batch.id}`);\n        if (!alreadyFinalized) {\n          finalizeBatch(queue, batchId, UPLOADER_EVENTS.BATCH_FINISH);\n        }\n        removeBatchItems(queue, batchId);\n        removeBatch(queue, batchId);\n      }\n    });\n  });\n};\nconst triggerUploaderBatchEvent = (queue, batchId, event) => {\n  const state = queue.getState(),\n    {\n      batch,\n      batchOptions\n    } = state.batches[batchId],\n    stateItems = state.items;\n  const eventBatch = {\n    ...unwrap(batch),\n    items: batch.items.map(({\n      id\n    }) => unwrap(stateItems[id]))\n  };\n  queue.trigger(event, eventBatch, unwrap(batchOptions));\n};\nconst getIsBatchReady = (queue, batchId) => {\n  const batch = getBatchFromState(queue.getState(), batchId);\n  return BATCH_READY_STATES.includes(batch.state);\n};\nconst detachRecycledFromPreviousBatch = (queue, item) => {\n  const {\n    previousBatch\n  } = item;\n  if (item.recycled && previousBatch && queue.getState().batches[previousBatch]) {\n    const {\n      id: batchId\n    } = getBatchFromItemId(queue, item.id);\n    if (batchId === previousBatch) {\n      queue.updateState(state => {\n        const batch = getBatchFromState(state, batchId);\n        const index = batch.items.findIndex(({\n          id\n        }) => id === item.id);\n        if (~index) {\n          batch.items.splice(index, 1);\n        }\n      });\n    }\n  }\n};\nconst preparePendingForUpload = (queue, uploadOptions) => {\n  queue.updateState(state => {\n    Object.keys(state.batches).forEach(batchId => {\n      const batchData = state.batches[batchId];\n      const {\n        batch,\n        batchOptions\n      } = batchData;\n      if (batch.state === BATCH_STATES.PENDING) {\n        batch.items.forEach(item => {\n          item.state = FILE_STATES.ADDED;\n        });\n        batch.state = BATCH_STATES.ADDED;\n        batchData.batchOptions = merge({}, batchOptions, uploadOptions);\n      }\n    });\n  });\n};\nconst removePendingBatches = queue => {\n  const batches = queue.getState().batches;\n  Object.keys(batches).filter(batchId => batches[batchId].batch.state === BATCH_STATES.PENDING).forEach(batchId => {\n    removeBatchItems(queue, batchId);\n    removeBatch(queue, batchId);\n  });\n};\nconst incrementBatchFinishedCounter = (queue, batchId) => {\n  queue.updateState(state => {\n    state.batches[batchId].finishedCounter += 1;\n  });\n};\nconst getIsBatchFinalized = batch => BATCH_FINISHED_STATES.includes(batch.state);\nconst clearBatchData = (queue, batchId) => {\n  queue.updateState(state => {\n    const {\n      items\n    } = getBatchFromState(state, batchId);\n    delete state.batches[batchId];\n    delete state.itemQueue[batchId];\n    const indx = state.batchQueue.indexOf(batchId);\n    if (~indx) {\n      state.batchQueue.splice(indx, 1);\n    }\n    if (state.currentBatch === batchId) {\n      state.currentBatch = null;\n    }\n    items.forEach(({\n      id\n    }) => {\n      delete state.items[id];\n      const activeIndex = state.activeIds.indexOf(id);\n      if (~activeIndex) {\n        state.activeIds.splice(activeIndex, 1);\n      }\n    });\n  });\n};\nexport { loadNewBatchForItem, isNewBatchStarting, cancelBatchWithId, cancelBatchForItem, getBatchFromItemId, getBatchDataFromItemId, cleanUpFinishedBatches, triggerUploaderBatchEvent, getIsBatchReady, getBatchFromState, detachRecycledFromPreviousBatch, preparePendingForUpload, removePendingBatches, incrementBatchFinishedCounter, getIsBatchFinalized, failBatchForItem, finalizeBatch, removeBatchItems, clearBatchData, isItemBatchStartPending };","map":{"version":3,"names":["BATCH_STATES","logger","merge","FILE_STATES","scheduleIdleWork","unwrap","UPLOADER_EVENTS","getItemsPrepareUpdater","finalizeItem","getIsItemExists","prepareBatchStartItems","BATCH_START","batch","items","Error","BATCH_READY_STATES","ADDED","PROCESSING","UPLOADING","BATCH_FINISHED_STATES","ABORTED","CANCELLED","FINISHED","ERROR","getBatchFromState","state","id","batches","getBatch","queue","getState","getBatchDataFromItemId","itemId","item","batchId","getBatchFromItemId","removeBatchItems","forEach","removeBatch","updateState","itemQueue","batchQueueIndex","batchQueue","indexOf","splice","pendingFlagIndex","batchesStartPending","finalizeBatch","eventType","finalState","additionalInfo","triggerUploaderBatchEvent","BATCH_FINALIZE","cancelBatchWithId","debugLog","BATCH_CANCEL","cancelBatchForItem","data","failBatchForItem","err","BATCH_ERROR","message","isItemBatchStartPending","includes","isNewBatchStarting","currentBatch","loadNewBatchForItem","push","then","cancelled","alreadyFinished","cleanUpFinishedBatches","Object","keys","finishedCounter","orgItemCount","alreadyFinalized","getIsBatchFinalized","completed","loaded","reduce","res","BATCH_PROGRESS","BATCH_FINISH","event","batchOptions","stateItems","eventBatch","map","trigger","getIsBatchReady","detachRecycledFromPreviousBatch","previousBatch","recycled","index","findIndex","preparePendingForUpload","uploadOptions","batchData","PENDING","removePendingBatches","filter","incrementBatchFinishedCounter","clearBatchData","indx","activeIndex","activeIds"],"sources":["C:/Users/y2006/OneDrive/바탕 화면/poba/poba/node_modules/@rpldy/uploader/lib/esm/queue/batchHelpers.js"],"sourcesContent":["import { BATCH_STATES, logger, merge, FILE_STATES, scheduleIdleWork } from \"@rpldy/shared\";\nimport { unwrap } from \"@rpldy/simple-state\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport { getItemsPrepareUpdater } from \"./preSendPrepare\";\nimport { finalizeItem, getIsItemExists } from \"./itemHelpers\";\nconst prepareBatchStartItems = getItemsPrepareUpdater(UPLOADER_EVENTS.BATCH_START, batch => batch.items, null, ({\n  batch\n} = {\n  batch: false\n}) => {\n  if (batch) {\n    throw new Error(`BATCH_START event handlers cannot update batch data. Only items & options`);\n  }\n});\nconst BATCH_READY_STATES = [BATCH_STATES.ADDED, BATCH_STATES.PROCESSING, BATCH_STATES.UPLOADING];\nconst BATCH_FINISHED_STATES = [BATCH_STATES.ABORTED, BATCH_STATES.CANCELLED, BATCH_STATES.FINISHED, BATCH_STATES.ERROR];\nconst getBatchFromState = (state, id) => state.batches[id].batch;\nconst getBatch = (queue, id) => {\n  return getBatchFromState(queue.getState(), id);\n};\nconst getBatchDataFromItemId = (queue, itemId) => {\n  const state = queue.getState();\n  const item = state.items[itemId];\n  return state.batches[item.batchId];\n};\nconst getBatchFromItemId = (queue, itemId) => {\n  return getBatchDataFromItemId(queue, itemId).batch;\n};\nconst removeBatchItems = (queue, batchId) => {\n  const batch = getBatch(queue, batchId);\n  batch.items.forEach(({\n    id\n  }) => finalizeItem(queue, id, true));\n};\nconst removeBatch = (queue, batchId) => {\n  queue.updateState(state => {\n    delete state.batches[batchId];\n    delete state.itemQueue[batchId];\n    const batchQueueIndex = state.batchQueue.indexOf(batchId);\n    if (~batchQueueIndex) {\n      state.batchQueue.splice(batchQueueIndex, 1);\n    }\n    const pendingFlagIndex = state.batchesStartPending.indexOf(batchId);\n    if (~pendingFlagIndex) {\n      state.batchesStartPending.splice(pendingFlagIndex, 1);\n    }\n  });\n};\nconst finalizeBatch = (queue, batchId, eventType, finalState = BATCH_STATES.FINISHED, additionalInfo) => {\n  queue.updateState(state => {\n    const batch = getBatchFromState(state, batchId);\n    batch.state = finalState;\n    if (additionalInfo) {\n      batch.additionalInfo = additionalInfo;\n    }\n  });\n  triggerUploaderBatchEvent(queue, batchId, eventType);\n  triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_FINALIZE);\n};\nconst cancelBatchWithId = (queue, batchId) => {\n  logger.debugLog(\"uploady.uploader.batchHelpers: cancelling batch: \", batchId);\n  finalizeBatch(queue, batchId, UPLOADER_EVENTS.BATCH_CANCEL, BATCH_STATES.CANCELLED);\n  removeBatchItems(queue, batchId);\n  removeBatch(queue, batchId);\n};\nconst cancelBatchForItem = (queue, itemId) => {\n  if (getIsItemExists(queue, itemId)) {\n    const data = getBatchDataFromItemId(queue, itemId),\n      batchId = data?.batch.id;\n    if (batchId) {\n      cancelBatchWithId(queue, batchId);\n    } else {\n      logger.debugLog(`uploady.uploader.batchHelpers: cancel batch called for batch already removed (item id = ${itemId})`);\n    }\n  }\n};\nconst failBatchForItem = (queue, itemId, err) => {\n  const batch = getBatchFromItemId(queue, itemId),\n    batchId = batch.id;\n  logger.debugLog(\"uploady.uploader.batchHelpers: failing batch: \", {\n    batch\n  });\n  finalizeBatch(queue, batchId, UPLOADER_EVENTS.BATCH_ERROR, BATCH_STATES.ERROR, err.message);\n  removeBatchItems(queue, batchId);\n  removeBatch(queue, batchId);\n};\nconst isItemBatchStartPending = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  return queue.getState().batchesStartPending.includes(batch.id);\n};\nconst isNewBatchStarting = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  return queue.getState().currentBatch !== batch.id;\n};\nconst loadNewBatchForItem = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  queue.updateState(state => {\n    state.batchesStartPending.push(batch.id);\n  });\n  return prepareBatchStartItems(queue, batch).then(({\n    cancelled\n  }) => {\n    let alreadyFinished = false;\n    queue.updateState(state => {\n      const pendingFlagIndex = state.batchesStartPending.indexOf(batch.id);\n      state.batchesStartPending.splice(pendingFlagIndex, 1);\n    });\n    if (!cancelled) {\n      alreadyFinished = !getIsItemExists(queue, itemId);\n      if (!alreadyFinished) {\n        queue.updateState(state => {\n          state.currentBatch = batch.id;\n        });\n      }\n    }\n    return !cancelled && !alreadyFinished;\n  });\n};\nconst cleanUpFinishedBatches = queue => {\n  scheduleIdleWork(() => {\n    const state = queue.getState();\n    Object.keys(state.batches).forEach(batchId => {\n      const {\n        batch,\n        finishedCounter\n      } = state.batches[batchId];\n      const {\n        orgItemCount\n      } = batch;\n      const alreadyFinalized = getIsBatchFinalized(batch);\n      if (orgItemCount === finishedCounter) {\n        if (!alreadyFinalized && batch.completed !== 100) {\n          queue.updateState(state => {\n            const batch = getBatchFromState(state, batchId);\n            batch.completed = 100;\n            batch.loaded = batch.items.reduce((res, {\n              loaded\n            }) => res + loaded, 0);\n          });\n          triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_PROGRESS);\n        }\n        queue.updateState(state => {\n          if (state.currentBatch === batchId) {\n            state.currentBatch = null;\n          }\n        });\n        logger.debugLog(`uploady.uploader.batchHelpers: cleaning up batch: ${batch.id}`);\n        if (!alreadyFinalized) {\n          finalizeBatch(queue, batchId, UPLOADER_EVENTS.BATCH_FINISH);\n        }\n        removeBatchItems(queue, batchId);\n        removeBatch(queue, batchId);\n      }\n    });\n  });\n};\nconst triggerUploaderBatchEvent = (queue, batchId, event) => {\n  const state = queue.getState(),\n    {\n      batch,\n      batchOptions\n    } = state.batches[batchId],\n    stateItems = state.items;\n  const eventBatch = {\n    ...unwrap(batch),\n    items: batch.items.map(({\n      id\n    }) => unwrap(stateItems[id]))\n  };\n  queue.trigger(event, eventBatch, unwrap(batchOptions));\n};\nconst getIsBatchReady = (queue, batchId) => {\n  const batch = getBatchFromState(queue.getState(), batchId);\n  return BATCH_READY_STATES.includes(batch.state);\n};\nconst detachRecycledFromPreviousBatch = (queue, item) => {\n  const {\n    previousBatch\n  } = item;\n  if (item.recycled && previousBatch && queue.getState().batches[previousBatch]) {\n    const {\n      id: batchId\n    } = getBatchFromItemId(queue, item.id);\n    if (batchId === previousBatch) {\n      queue.updateState(state => {\n        const batch = getBatchFromState(state, batchId);\n        const index = batch.items.findIndex(({\n          id\n        }) => id === item.id);\n        if (~index) {\n          batch.items.splice(index, 1);\n        }\n      });\n    }\n  }\n};\nconst preparePendingForUpload = (queue, uploadOptions) => {\n  queue.updateState(state => {\n    Object.keys(state.batches).forEach(batchId => {\n      const batchData = state.batches[batchId];\n      const {\n        batch,\n        batchOptions\n      } = batchData;\n      if (batch.state === BATCH_STATES.PENDING) {\n        batch.items.forEach(item => {\n          item.state = FILE_STATES.ADDED;\n        });\n        batch.state = BATCH_STATES.ADDED;\n        batchData.batchOptions = merge({}, batchOptions, uploadOptions);\n      }\n    });\n  });\n};\nconst removePendingBatches = queue => {\n  const batches = queue.getState().batches;\n  Object.keys(batches).filter(batchId => batches[batchId].batch.state === BATCH_STATES.PENDING).forEach(batchId => {\n    removeBatchItems(queue, batchId);\n    removeBatch(queue, batchId);\n  });\n};\nconst incrementBatchFinishedCounter = (queue, batchId) => {\n  queue.updateState(state => {\n    state.batches[batchId].finishedCounter += 1;\n  });\n};\nconst getIsBatchFinalized = batch => BATCH_FINISHED_STATES.includes(batch.state);\nconst clearBatchData = (queue, batchId) => {\n  queue.updateState(state => {\n    const {\n      items\n    } = getBatchFromState(state, batchId);\n    delete state.batches[batchId];\n    delete state.itemQueue[batchId];\n    const indx = state.batchQueue.indexOf(batchId);\n    if (~indx) {\n      state.batchQueue.splice(indx, 1);\n    }\n    if (state.currentBatch === batchId) {\n      state.currentBatch = null;\n    }\n    items.forEach(({\n      id\n    }) => {\n      delete state.items[id];\n      const activeIndex = state.activeIds.indexOf(id);\n      if (~activeIndex) {\n        state.activeIds.splice(activeIndex, 1);\n      }\n    });\n  });\n};\nexport { loadNewBatchForItem, isNewBatchStarting, cancelBatchWithId, cancelBatchForItem, getBatchFromItemId, getBatchDataFromItemId, cleanUpFinishedBatches, triggerUploaderBatchEvent, getIsBatchReady, getBatchFromState, detachRecycledFromPreviousBatch, preparePendingForUpload, removePendingBatches, incrementBatchFinishedCounter, getIsBatchFinalized, failBatchForItem, finalizeBatch, removeBatchItems, clearBatchData, isItemBatchStartPending };"],"mappings":"AAAA,SAASA,YAAY,EAAEC,MAAM,EAAEC,KAAK,EAAEC,WAAW,EAAEC,gBAAgB,QAAQ,eAAe;AAC1F,SAASC,MAAM,QAAQ,qBAAqB;AAC5C,SAASC,eAAe,QAAQ,WAAW;AAC3C,SAASC,sBAAsB,QAAQ,kBAAkB;AACzD,SAASC,YAAY,EAAEC,eAAe,QAAQ,eAAe;AAC7D,MAAMC,sBAAsB,GAAGH,sBAAsB,CAACD,eAAe,CAACK,WAAW,EAAEC,KAAK,IAAIA,KAAK,CAACC,KAAK,EAAE,IAAI,EAAE,CAAC;EAC9GD;AACF,CAAC,GAAG;EACFA,KAAK,EAAE;AACT,CAAC,KAAK;EACJ,IAAIA,KAAK,EAAE;IACT,MAAM,IAAIE,KAAK,CAAC,2EAA2E,CAAC;EAC9F;AACF,CAAC,CAAC;AACF,MAAMC,kBAAkB,GAAG,CAACf,YAAY,CAACgB,KAAK,EAAEhB,YAAY,CAACiB,UAAU,EAAEjB,YAAY,CAACkB,SAAS,CAAC;AAChG,MAAMC,qBAAqB,GAAG,CAACnB,YAAY,CAACoB,OAAO,EAAEpB,YAAY,CAACqB,SAAS,EAAErB,YAAY,CAACsB,QAAQ,EAAEtB,YAAY,CAACuB,KAAK,CAAC;AACvH,MAAMC,iBAAiB,GAAGA,CAACC,KAAK,EAAEC,EAAE,KAAKD,KAAK,CAACE,OAAO,CAACD,EAAE,CAAC,CAACd,KAAK;AAChE,MAAMgB,QAAQ,GAAGA,CAACC,KAAK,EAAEH,EAAE,KAAK;EAC9B,OAAOF,iBAAiB,CAACK,KAAK,CAACC,QAAQ,CAAC,CAAC,EAAEJ,EAAE,CAAC;AAChD,CAAC;AACD,MAAMK,sBAAsB,GAAGA,CAACF,KAAK,EAAEG,MAAM,KAAK;EAChD,MAAMP,KAAK,GAAGI,KAAK,CAACC,QAAQ,CAAC,CAAC;EAC9B,MAAMG,IAAI,GAAGR,KAAK,CAACZ,KAAK,CAACmB,MAAM,CAAC;EAChC,OAAOP,KAAK,CAACE,OAAO,CAACM,IAAI,CAACC,OAAO,CAAC;AACpC,CAAC;AACD,MAAMC,kBAAkB,GAAGA,CAACN,KAAK,EAAEG,MAAM,KAAK;EAC5C,OAAOD,sBAAsB,CAACF,KAAK,EAAEG,MAAM,CAAC,CAACpB,KAAK;AACpD,CAAC;AACD,MAAMwB,gBAAgB,GAAGA,CAACP,KAAK,EAAEK,OAAO,KAAK;EAC3C,MAAMtB,KAAK,GAAGgB,QAAQ,CAACC,KAAK,EAAEK,OAAO,CAAC;EACtCtB,KAAK,CAACC,KAAK,CAACwB,OAAO,CAAC,CAAC;IACnBX;EACF,CAAC,KAAKlB,YAAY,CAACqB,KAAK,EAAEH,EAAE,EAAE,IAAI,CAAC,CAAC;AACtC,CAAC;AACD,MAAMY,WAAW,GAAGA,CAACT,KAAK,EAAEK,OAAO,KAAK;EACtCL,KAAK,CAACU,WAAW,CAACd,KAAK,IAAI;IACzB,OAAOA,KAAK,CAACE,OAAO,CAACO,OAAO,CAAC;IAC7B,OAAOT,KAAK,CAACe,SAAS,CAACN,OAAO,CAAC;IAC/B,MAAMO,eAAe,GAAGhB,KAAK,CAACiB,UAAU,CAACC,OAAO,CAACT,OAAO,CAAC;IACzD,IAAI,CAACO,eAAe,EAAE;MACpBhB,KAAK,CAACiB,UAAU,CAACE,MAAM,CAACH,eAAe,EAAE,CAAC,CAAC;IAC7C;IACA,MAAMI,gBAAgB,GAAGpB,KAAK,CAACqB,mBAAmB,CAACH,OAAO,CAACT,OAAO,CAAC;IACnE,IAAI,CAACW,gBAAgB,EAAE;MACrBpB,KAAK,CAACqB,mBAAmB,CAACF,MAAM,CAACC,gBAAgB,EAAE,CAAC,CAAC;IACvD;EACF,CAAC,CAAC;AACJ,CAAC;AACD,MAAME,aAAa,GAAGA,CAAClB,KAAK,EAAEK,OAAO,EAAEc,SAAS,EAAEC,UAAU,GAAGjD,YAAY,CAACsB,QAAQ,EAAE4B,cAAc,KAAK;EACvGrB,KAAK,CAACU,WAAW,CAACd,KAAK,IAAI;IACzB,MAAMb,KAAK,GAAGY,iBAAiB,CAACC,KAAK,EAAES,OAAO,CAAC;IAC/CtB,KAAK,CAACa,KAAK,GAAGwB,UAAU;IACxB,IAAIC,cAAc,EAAE;MAClBtC,KAAK,CAACsC,cAAc,GAAGA,cAAc;IACvC;EACF,CAAC,CAAC;EACFC,yBAAyB,CAACtB,KAAK,EAAEK,OAAO,EAAEc,SAAS,CAAC;EACpDG,yBAAyB,CAACtB,KAAK,EAAEK,OAAO,EAAE5B,eAAe,CAAC8C,cAAc,CAAC;AAC3E,CAAC;AACD,MAAMC,iBAAiB,GAAGA,CAACxB,KAAK,EAAEK,OAAO,KAAK;EAC5CjC,MAAM,CAACqD,QAAQ,CAAC,mDAAmD,EAAEpB,OAAO,CAAC;EAC7Ea,aAAa,CAAClB,KAAK,EAAEK,OAAO,EAAE5B,eAAe,CAACiD,YAAY,EAAEvD,YAAY,CAACqB,SAAS,CAAC;EACnFe,gBAAgB,CAACP,KAAK,EAAEK,OAAO,CAAC;EAChCI,WAAW,CAACT,KAAK,EAAEK,OAAO,CAAC;AAC7B,CAAC;AACD,MAAMsB,kBAAkB,GAAGA,CAAC3B,KAAK,EAAEG,MAAM,KAAK;EAC5C,IAAIvB,eAAe,CAACoB,KAAK,EAAEG,MAAM,CAAC,EAAE;IAClC,MAAMyB,IAAI,GAAG1B,sBAAsB,CAACF,KAAK,EAAEG,MAAM,CAAC;MAChDE,OAAO,GAAGuB,IAAI,EAAE7C,KAAK,CAACc,EAAE;IAC1B,IAAIQ,OAAO,EAAE;MACXmB,iBAAiB,CAACxB,KAAK,EAAEK,OAAO,CAAC;IACnC,CAAC,MAAM;MACLjC,MAAM,CAACqD,QAAQ,CAAC,2FAA2FtB,MAAM,GAAG,CAAC;IACvH;EACF;AACF,CAAC;AACD,MAAM0B,gBAAgB,GAAGA,CAAC7B,KAAK,EAAEG,MAAM,EAAE2B,GAAG,KAAK;EAC/C,MAAM/C,KAAK,GAAGuB,kBAAkB,CAACN,KAAK,EAAEG,MAAM,CAAC;IAC7CE,OAAO,GAAGtB,KAAK,CAACc,EAAE;EACpBzB,MAAM,CAACqD,QAAQ,CAAC,gDAAgD,EAAE;IAChE1C;EACF,CAAC,CAAC;EACFmC,aAAa,CAAClB,KAAK,EAAEK,OAAO,EAAE5B,eAAe,CAACsD,WAAW,EAAE5D,YAAY,CAACuB,KAAK,EAAEoC,GAAG,CAACE,OAAO,CAAC;EAC3FzB,gBAAgB,CAACP,KAAK,EAAEK,OAAO,CAAC;EAChCI,WAAW,CAACT,KAAK,EAAEK,OAAO,CAAC;AAC7B,CAAC;AACD,MAAM4B,uBAAuB,GAAGA,CAACjC,KAAK,EAAEG,MAAM,KAAK;EACjD,MAAMpB,KAAK,GAAGuB,kBAAkB,CAACN,KAAK,EAAEG,MAAM,CAAC;EAC/C,OAAOH,KAAK,CAACC,QAAQ,CAAC,CAAC,CAACgB,mBAAmB,CAACiB,QAAQ,CAACnD,KAAK,CAACc,EAAE,CAAC;AAChE,CAAC;AACD,MAAMsC,kBAAkB,GAAGA,CAACnC,KAAK,EAAEG,MAAM,KAAK;EAC5C,MAAMpB,KAAK,GAAGuB,kBAAkB,CAACN,KAAK,EAAEG,MAAM,CAAC;EAC/C,OAAOH,KAAK,CAACC,QAAQ,CAAC,CAAC,CAACmC,YAAY,KAAKrD,KAAK,CAACc,EAAE;AACnD,CAAC;AACD,MAAMwC,mBAAmB,GAAGA,CAACrC,KAAK,EAAEG,MAAM,KAAK;EAC7C,MAAMpB,KAAK,GAAGuB,kBAAkB,CAACN,KAAK,EAAEG,MAAM,CAAC;EAC/CH,KAAK,CAACU,WAAW,CAACd,KAAK,IAAI;IACzBA,KAAK,CAACqB,mBAAmB,CAACqB,IAAI,CAACvD,KAAK,CAACc,EAAE,CAAC;EAC1C,CAAC,CAAC;EACF,OAAOhB,sBAAsB,CAACmB,KAAK,EAAEjB,KAAK,CAAC,CAACwD,IAAI,CAAC,CAAC;IAChDC;EACF,CAAC,KAAK;IACJ,IAAIC,eAAe,GAAG,KAAK;IAC3BzC,KAAK,CAACU,WAAW,CAACd,KAAK,IAAI;MACzB,MAAMoB,gBAAgB,GAAGpB,KAAK,CAACqB,mBAAmB,CAACH,OAAO,CAAC/B,KAAK,CAACc,EAAE,CAAC;MACpED,KAAK,CAACqB,mBAAmB,CAACF,MAAM,CAACC,gBAAgB,EAAE,CAAC,CAAC;IACvD,CAAC,CAAC;IACF,IAAI,CAACwB,SAAS,EAAE;MACdC,eAAe,GAAG,CAAC7D,eAAe,CAACoB,KAAK,EAAEG,MAAM,CAAC;MACjD,IAAI,CAACsC,eAAe,EAAE;QACpBzC,KAAK,CAACU,WAAW,CAACd,KAAK,IAAI;UACzBA,KAAK,CAACwC,YAAY,GAAGrD,KAAK,CAACc,EAAE;QAC/B,CAAC,CAAC;MACJ;IACF;IACA,OAAO,CAAC2C,SAAS,IAAI,CAACC,eAAe;EACvC,CAAC,CAAC;AACJ,CAAC;AACD,MAAMC,sBAAsB,GAAG1C,KAAK,IAAI;EACtCzB,gBAAgB,CAAC,MAAM;IACrB,MAAMqB,KAAK,GAAGI,KAAK,CAACC,QAAQ,CAAC,CAAC;IAC9B0C,MAAM,CAACC,IAAI,CAAChD,KAAK,CAACE,OAAO,CAAC,CAACU,OAAO,CAACH,OAAO,IAAI;MAC5C,MAAM;QACJtB,KAAK;QACL8D;MACF,CAAC,GAAGjD,KAAK,CAACE,OAAO,CAACO,OAAO,CAAC;MAC1B,MAAM;QACJyC;MACF,CAAC,GAAG/D,KAAK;MACT,MAAMgE,gBAAgB,GAAGC,mBAAmB,CAACjE,KAAK,CAAC;MACnD,IAAI+D,YAAY,KAAKD,eAAe,EAAE;QACpC,IAAI,CAACE,gBAAgB,IAAIhE,KAAK,CAACkE,SAAS,KAAK,GAAG,EAAE;UAChDjD,KAAK,CAACU,WAAW,CAACd,KAAK,IAAI;YACzB,MAAMb,KAAK,GAAGY,iBAAiB,CAACC,KAAK,EAAES,OAAO,CAAC;YAC/CtB,KAAK,CAACkE,SAAS,GAAG,GAAG;YACrBlE,KAAK,CAACmE,MAAM,GAAGnE,KAAK,CAACC,KAAK,CAACmE,MAAM,CAAC,CAACC,GAAG,EAAE;cACtCF;YACF,CAAC,KAAKE,GAAG,GAAGF,MAAM,EAAE,CAAC,CAAC;UACxB,CAAC,CAAC;UACF5B,yBAAyB,CAACtB,KAAK,EAAEK,OAAO,EAAE5B,eAAe,CAAC4E,cAAc,CAAC;QAC3E;QACArD,KAAK,CAACU,WAAW,CAACd,KAAK,IAAI;UACzB,IAAIA,KAAK,CAACwC,YAAY,KAAK/B,OAAO,EAAE;YAClCT,KAAK,CAACwC,YAAY,GAAG,IAAI;UAC3B;QACF,CAAC,CAAC;QACFhE,MAAM,CAACqD,QAAQ,CAAC,qDAAqD1C,KAAK,CAACc,EAAE,EAAE,CAAC;QAChF,IAAI,CAACkD,gBAAgB,EAAE;UACrB7B,aAAa,CAAClB,KAAK,EAAEK,OAAO,EAAE5B,eAAe,CAAC6E,YAAY,CAAC;QAC7D;QACA/C,gBAAgB,CAACP,KAAK,EAAEK,OAAO,CAAC;QAChCI,WAAW,CAACT,KAAK,EAAEK,OAAO,CAAC;MAC7B;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ,CAAC;AACD,MAAMiB,yBAAyB,GAAGA,CAACtB,KAAK,EAAEK,OAAO,EAAEkD,KAAK,KAAK;EAC3D,MAAM3D,KAAK,GAAGI,KAAK,CAACC,QAAQ,CAAC,CAAC;IAC5B;MACElB,KAAK;MACLyE;IACF,CAAC,GAAG5D,KAAK,CAACE,OAAO,CAACO,OAAO,CAAC;IAC1BoD,UAAU,GAAG7D,KAAK,CAACZ,KAAK;EAC1B,MAAM0E,UAAU,GAAG;IACjB,GAAGlF,MAAM,CAACO,KAAK,CAAC;IAChBC,KAAK,EAAED,KAAK,CAACC,KAAK,CAAC2E,GAAG,CAAC,CAAC;MACtB9D;IACF,CAAC,KAAKrB,MAAM,CAACiF,UAAU,CAAC5D,EAAE,CAAC,CAAC;EAC9B,CAAC;EACDG,KAAK,CAAC4D,OAAO,CAACL,KAAK,EAAEG,UAAU,EAAElF,MAAM,CAACgF,YAAY,CAAC,CAAC;AACxD,CAAC;AACD,MAAMK,eAAe,GAAGA,CAAC7D,KAAK,EAAEK,OAAO,KAAK;EAC1C,MAAMtB,KAAK,GAAGY,iBAAiB,CAACK,KAAK,CAACC,QAAQ,CAAC,CAAC,EAAEI,OAAO,CAAC;EAC1D,OAAOnB,kBAAkB,CAACgD,QAAQ,CAACnD,KAAK,CAACa,KAAK,CAAC;AACjD,CAAC;AACD,MAAMkE,+BAA+B,GAAGA,CAAC9D,KAAK,EAAEI,IAAI,KAAK;EACvD,MAAM;IACJ2D;EACF,CAAC,GAAG3D,IAAI;EACR,IAAIA,IAAI,CAAC4D,QAAQ,IAAID,aAAa,IAAI/D,KAAK,CAACC,QAAQ,CAAC,CAAC,CAACH,OAAO,CAACiE,aAAa,CAAC,EAAE;IAC7E,MAAM;MACJlE,EAAE,EAAEQ;IACN,CAAC,GAAGC,kBAAkB,CAACN,KAAK,EAAEI,IAAI,CAACP,EAAE,CAAC;IACtC,IAAIQ,OAAO,KAAK0D,aAAa,EAAE;MAC7B/D,KAAK,CAACU,WAAW,CAACd,KAAK,IAAI;QACzB,MAAMb,KAAK,GAAGY,iBAAiB,CAACC,KAAK,EAAES,OAAO,CAAC;QAC/C,MAAM4D,KAAK,GAAGlF,KAAK,CAACC,KAAK,CAACkF,SAAS,CAAC,CAAC;UACnCrE;QACF,CAAC,KAAKA,EAAE,KAAKO,IAAI,CAACP,EAAE,CAAC;QACrB,IAAI,CAACoE,KAAK,EAAE;UACVlF,KAAK,CAACC,KAAK,CAAC+B,MAAM,CAACkD,KAAK,EAAE,CAAC,CAAC;QAC9B;MACF,CAAC,CAAC;IACJ;EACF;AACF,CAAC;AACD,MAAME,uBAAuB,GAAGA,CAACnE,KAAK,EAAEoE,aAAa,KAAK;EACxDpE,KAAK,CAACU,WAAW,CAACd,KAAK,IAAI;IACzB+C,MAAM,CAACC,IAAI,CAAChD,KAAK,CAACE,OAAO,CAAC,CAACU,OAAO,CAACH,OAAO,IAAI;MAC5C,MAAMgE,SAAS,GAAGzE,KAAK,CAACE,OAAO,CAACO,OAAO,CAAC;MACxC,MAAM;QACJtB,KAAK;QACLyE;MACF,CAAC,GAAGa,SAAS;MACb,IAAItF,KAAK,CAACa,KAAK,KAAKzB,YAAY,CAACmG,OAAO,EAAE;QACxCvF,KAAK,CAACC,KAAK,CAACwB,OAAO,CAACJ,IAAI,IAAI;UAC1BA,IAAI,CAACR,KAAK,GAAGtB,WAAW,CAACa,KAAK;QAChC,CAAC,CAAC;QACFJ,KAAK,CAACa,KAAK,GAAGzB,YAAY,CAACgB,KAAK;QAChCkF,SAAS,CAACb,YAAY,GAAGnF,KAAK,CAAC,CAAC,CAAC,EAAEmF,YAAY,EAAEY,aAAa,CAAC;MACjE;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ,CAAC;AACD,MAAMG,oBAAoB,GAAGvE,KAAK,IAAI;EACpC,MAAMF,OAAO,GAAGE,KAAK,CAACC,QAAQ,CAAC,CAAC,CAACH,OAAO;EACxC6C,MAAM,CAACC,IAAI,CAAC9C,OAAO,CAAC,CAAC0E,MAAM,CAACnE,OAAO,IAAIP,OAAO,CAACO,OAAO,CAAC,CAACtB,KAAK,CAACa,KAAK,KAAKzB,YAAY,CAACmG,OAAO,CAAC,CAAC9D,OAAO,CAACH,OAAO,IAAI;IAC/GE,gBAAgB,CAACP,KAAK,EAAEK,OAAO,CAAC;IAChCI,WAAW,CAACT,KAAK,EAAEK,OAAO,CAAC;EAC7B,CAAC,CAAC;AACJ,CAAC;AACD,MAAMoE,6BAA6B,GAAGA,CAACzE,KAAK,EAAEK,OAAO,KAAK;EACxDL,KAAK,CAACU,WAAW,CAACd,KAAK,IAAI;IACzBA,KAAK,CAACE,OAAO,CAACO,OAAO,CAAC,CAACwC,eAAe,IAAI,CAAC;EAC7C,CAAC,CAAC;AACJ,CAAC;AACD,MAAMG,mBAAmB,GAAGjE,KAAK,IAAIO,qBAAqB,CAAC4C,QAAQ,CAACnD,KAAK,CAACa,KAAK,CAAC;AAChF,MAAM8E,cAAc,GAAGA,CAAC1E,KAAK,EAAEK,OAAO,KAAK;EACzCL,KAAK,CAACU,WAAW,CAACd,KAAK,IAAI;IACzB,MAAM;MACJZ;IACF,CAAC,GAAGW,iBAAiB,CAACC,KAAK,EAAES,OAAO,CAAC;IACrC,OAAOT,KAAK,CAACE,OAAO,CAACO,OAAO,CAAC;IAC7B,OAAOT,KAAK,CAACe,SAAS,CAACN,OAAO,CAAC;IAC/B,MAAMsE,IAAI,GAAG/E,KAAK,CAACiB,UAAU,CAACC,OAAO,CAACT,OAAO,CAAC;IAC9C,IAAI,CAACsE,IAAI,EAAE;MACT/E,KAAK,CAACiB,UAAU,CAACE,MAAM,CAAC4D,IAAI,EAAE,CAAC,CAAC;IAClC;IACA,IAAI/E,KAAK,CAACwC,YAAY,KAAK/B,OAAO,EAAE;MAClCT,KAAK,CAACwC,YAAY,GAAG,IAAI;IAC3B;IACApD,KAAK,CAACwB,OAAO,CAAC,CAAC;MACbX;IACF,CAAC,KAAK;MACJ,OAAOD,KAAK,CAACZ,KAAK,CAACa,EAAE,CAAC;MACtB,MAAM+E,WAAW,GAAGhF,KAAK,CAACiF,SAAS,CAAC/D,OAAO,CAACjB,EAAE,CAAC;MAC/C,IAAI,CAAC+E,WAAW,EAAE;QAChBhF,KAAK,CAACiF,SAAS,CAAC9D,MAAM,CAAC6D,WAAW,EAAE,CAAC,CAAC;MACxC;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ,CAAC;AACD,SAASvC,mBAAmB,EAAEF,kBAAkB,EAAEX,iBAAiB,EAAEG,kBAAkB,EAAErB,kBAAkB,EAAEJ,sBAAsB,EAAEwC,sBAAsB,EAAEpB,yBAAyB,EAAEuC,eAAe,EAAElE,iBAAiB,EAAEmE,+BAA+B,EAAEK,uBAAuB,EAAEI,oBAAoB,EAAEE,6BAA6B,EAAEzB,mBAAmB,EAAEnB,gBAAgB,EAAEX,aAAa,EAAEX,gBAAgB,EAAEmE,cAAc,EAAEzC,uBAAuB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}