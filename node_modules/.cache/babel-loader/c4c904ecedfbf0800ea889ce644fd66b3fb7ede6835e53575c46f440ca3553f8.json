{"ast":null,"code":"import { getMerge, isSamePropInArrays, logger, triggerUpdater } from \"@rpldy/shared\";\nimport { getIsItemFinalized } from \"./itemHelpers\";\nconst mergeWithUndefined = getMerge({\n  undefinedOverwrites: true\n});\nconst processPrepareResponse = (eventType, items, options, updated) => {\n  let usedOptions = options,\n    usedItems = items;\n  if (updated) {\n    logger.debugLog(`uploader.queue: REQUEST_PRE_SEND(${eventType}) event returned updated items/options`, updated);\n    if (updated.items) {\n      if (updated.items.length !== items.length || !isSamePropInArrays(updated.items, items, [\"id\", \"batchId\", \"recycled\"])) {\n        throw new Error(`REQUEST_PRE_SEND(${eventType}) event handlers must return same items with same ids`);\n      }\n      usedItems = updated.items;\n    }\n    if (updated.options) {\n      usedOptions = mergeWithUndefined({}, options, updated.options);\n    }\n  }\n  return {\n    items: usedItems,\n    options: usedOptions,\n    cancelled: updated === false\n  };\n};\nconst triggerItemsPrepareEvent = (queue, eventSubject, items, options, eventType, validateResponse) => triggerUpdater(queue.trigger, eventType, eventSubject, options).then(updated => {\n  validateResponse?.(updated);\n  return processPrepareResponse(eventType, items, options, updated);\n});\nconst persistPrepareResponse = (queue, prepared) => {\n  if (prepared.items[0] && queue.getState().batches[prepared.items[0].batchId]) {\n    queue.updateState(state => {\n      prepared.items.forEach(i => {\n        if (!getIsItemFinalized(state.items[i.id])) {\n          state.items[i.id] = i;\n        }\n      });\n      state.batches[prepared.items[0].batchId].batchOptions = prepared.options;\n    });\n    const updatedState = queue.getState();\n    prepared.items = prepared.items.map(item => updatedState.items[item.id]);\n    prepared.options = updatedState.batches[prepared.items[0].batchId].batchOptions;\n  }\n};\nconst prepareItems = (queue, subject, retrieveItemsFromSubject, createEventSubject, validateResponse, eventType) => {\n  const items = retrieveItemsFromSubject(subject);\n  const batchOptions = queue.getState().batches[items[0].batchId].batchOptions;\n  const eventSubject = createEventSubject?.(subject, batchOptions) || subject;\n  return triggerItemsPrepareEvent(queue, eventSubject, items, batchOptions, eventType, validateResponse).then(prepared => {\n    if (!prepared.cancelled) {\n      persistPrepareResponse(queue, prepared);\n    }\n    return prepared;\n  });\n};\nconst getItemsPrepareUpdater = (eventType, retrieveItemsFromSubject, createEventSubject = null, validateResponse = null) => (queue, subject) => prepareItems(queue, subject, retrieveItemsFromSubject, createEventSubject, validateResponse, eventType);\nexport { getItemsPrepareUpdater };","map":{"version":3,"names":["getMerge","isSamePropInArrays","logger","triggerUpdater","getIsItemFinalized","mergeWithUndefined","undefinedOverwrites","processPrepareResponse","eventType","items","options","updated","usedOptions","usedItems","debugLog","length","Error","cancelled","triggerItemsPrepareEvent","queue","eventSubject","validateResponse","trigger","then","persistPrepareResponse","prepared","getState","batches","batchId","updateState","state","forEach","i","id","batchOptions","updatedState","map","item","prepareItems","subject","retrieveItemsFromSubject","createEventSubject","getItemsPrepareUpdater"],"sources":["C:/Users/y2006/OneDrive/바탕 화면/poba/poba/node_modules/@rpldy/uploader/lib/esm/queue/preSendPrepare.js"],"sourcesContent":["import { getMerge, isSamePropInArrays, logger, triggerUpdater } from \"@rpldy/shared\";\nimport { getIsItemFinalized } from \"./itemHelpers\";\nconst mergeWithUndefined = getMerge({\n  undefinedOverwrites: true\n});\nconst processPrepareResponse = (eventType, items, options, updated) => {\n  let usedOptions = options,\n    usedItems = items;\n  if (updated) {\n    logger.debugLog(`uploader.queue: REQUEST_PRE_SEND(${eventType}) event returned updated items/options`, updated);\n    if (updated.items) {\n      if (updated.items.length !== items.length || !isSamePropInArrays(updated.items, items, [\"id\", \"batchId\", \"recycled\"])) {\n        throw new Error(`REQUEST_PRE_SEND(${eventType}) event handlers must return same items with same ids`);\n      }\n      usedItems = updated.items;\n    }\n    if (updated.options) {\n      usedOptions = mergeWithUndefined({}, options, updated.options);\n    }\n  }\n  return {\n    items: usedItems,\n    options: usedOptions,\n    cancelled: updated === false\n  };\n};\nconst triggerItemsPrepareEvent = (queue, eventSubject, items, options, eventType, validateResponse) => triggerUpdater(queue.trigger, eventType, eventSubject, options).then(updated => {\n  validateResponse?.(updated);\n  return processPrepareResponse(eventType, items, options, updated);\n});\nconst persistPrepareResponse = (queue, prepared) => {\n  if (prepared.items[0] && queue.getState().batches[prepared.items[0].batchId]) {\n    queue.updateState(state => {\n      prepared.items.forEach(i => {\n        if (!getIsItemFinalized(state.items[i.id])) {\n          state.items[i.id] = i;\n        }\n      });\n      state.batches[prepared.items[0].batchId].batchOptions = prepared.options;\n    });\n    const updatedState = queue.getState();\n    prepared.items = prepared.items.map(item => updatedState.items[item.id]);\n    prepared.options = updatedState.batches[prepared.items[0].batchId].batchOptions;\n  }\n};\nconst prepareItems = (queue, subject, retrieveItemsFromSubject, createEventSubject, validateResponse, eventType) => {\n  const items = retrieveItemsFromSubject(subject);\n  const batchOptions = queue.getState().batches[items[0].batchId].batchOptions;\n  const eventSubject = createEventSubject?.(subject, batchOptions) || subject;\n  return triggerItemsPrepareEvent(queue, eventSubject, items, batchOptions, eventType, validateResponse).then(prepared => {\n    if (!prepared.cancelled) {\n      persistPrepareResponse(queue, prepared);\n    }\n    return prepared;\n  });\n};\nconst getItemsPrepareUpdater = (eventType, retrieveItemsFromSubject, createEventSubject = null, validateResponse = null) => (queue, subject) => prepareItems(queue, subject, retrieveItemsFromSubject, createEventSubject, validateResponse, eventType);\nexport { getItemsPrepareUpdater };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}