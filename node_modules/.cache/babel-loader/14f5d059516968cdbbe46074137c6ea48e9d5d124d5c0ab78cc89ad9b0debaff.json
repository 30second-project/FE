{"ast":null,"code":"import { logger, FILE_STATES, request, parseResponseHeaders, pick, merge, isPromise } from \"@rpldy/shared\";\nimport { XHR_SENDER_TYPE } from \"../consts\";\nimport MissingUrlError from \"../MissingUrlError\";\nimport prepareFormData from \"./prepareFormData\";\nexport const SUCCESS_CODES = [200, 201, 202, 203, 204];\nconst getRequestData = (items, options) => {\n  let data;\n  if (options.sendWithFormData) {\n    logger.debugLog(`uploady.sender: sending ${items.length} item(s) as form data`);\n    data = prepareFormData(items, options);\n  } else {\n    if (items.length > 1) {\n      throw new Error(`XHR Sender - Request without form data can only contain 1 item. received ${items.length}`);\n    }\n    const item = items[0];\n    logger.debugLog(`uploady.sender: sending item ${item.id} as request body`);\n    data = item.file || item.url;\n  }\n  return data;\n};\nconst makeRequest = (items, url, options, onProgress, config) => {\n  let xhr;\n  const data = config?.getRequestData ? config.getRequestData(items, options) : getRequestData(items, options);\n  const issueRequest = (requestUrl = url, requestData = data, requestOptions) => {\n    const resolvedRequestOptions = merge({\n      ...pick(options, [\"method\", \"headers\", \"withCredentials\"]),\n      preSend: req => {\n        req.upload.onprogress = e => {\n          if (e.lengthComputable && onProgress) {\n            onProgress(e, items.slice());\n          }\n        };\n      }\n    }, requestOptions);\n    const realPXhr = request(requestUrl, requestData, resolvedRequestOptions);\n    xhr = realPXhr.xhr;\n    return realPXhr;\n  };\n  const pXhr = config?.preRequestHandler ? config.preRequestHandler(issueRequest, items, url, options, onProgress, config) : issueRequest();\n  return {\n    url,\n    count: items.length,\n    pXhr,\n    getXhr: () => xhr,\n    aborted: false\n  };\n};\nconst parseResponseJson = (response, headers, options) => {\n  let parsed = response;\n  const ct = headers?.[\"content-type\"];\n  if (options.forceJsonResponse || ct?.includes(\"json\")) {\n    try {\n      parsed = JSON.parse(response);\n    } catch {}\n  }\n  return parsed;\n};\nconst checkIsResponseSuccessful = (xhr, options) => {\n  const isSuccess = options.isSuccessfulCall ? options.isSuccessfulCall(xhr) : SUCCESS_CODES.includes(xhr.status);\n  return isPromise(isSuccess) ? isSuccess : Promise.resolve(isSuccess);\n};\nconst processResponse = (sendRequest, options) => sendRequest.pXhr.then(xhr => {\n  logger.debugLog(\"uploady.sender: received upload response \", xhr);\n  return checkIsResponseSuccessful(xhr, options).then(isSuccess => {\n    const state = isSuccess ? FILE_STATES.FINISHED : FILE_STATES.ERROR;\n    const status = xhr.status;\n    const resHeaders = parseResponseHeaders(xhr);\n    const response = {\n      data: options.formatServerResponse?.(xhr.response, status, resHeaders) ?? parseResponseJson(xhr.response, resHeaders, options),\n      headers: resHeaders\n    };\n    return {\n      status,\n      state,\n      response\n    };\n  });\n}).catch(error => {\n  let state, response;\n  if (sendRequest.aborted) {\n    state = FILE_STATES.ABORTED;\n    response = \"aborted\";\n  } else {\n    logger.debugLog(\"uploady.sender: upload failed: \", error);\n    state = FILE_STATES.ERROR;\n    response = error;\n  }\n  return {\n    error: true,\n    state,\n    response,\n    status: 0\n  };\n});\nconst abortRequest = sendRequest => {\n  let abortCalled = false;\n  const {\n    aborted,\n    getXhr\n  } = sendRequest;\n  const xhr = getXhr();\n  if (!aborted && xhr && xhr.readyState && xhr.readyState !== 4) {\n    logger.debugLog(`uploady.sender: cancelling request with ${sendRequest.count} items to: ${sendRequest.url}`);\n    xhr.abort();\n    sendRequest.aborted = true;\n    abortCalled = true;\n  }\n  return abortCalled;\n};\nconst getXhrSend = config => (items, url, options, onProgress) => {\n  if (!url) {\n    throw new MissingUrlError(XHR_SENDER_TYPE);\n  }\n  logger.debugLog(\"uploady.sender: sending file: \", {\n    items,\n    url,\n    options\n  });\n  const sendRequest = makeRequest(items, url, options, onProgress, config);\n  return {\n    request: processResponse(sendRequest, options),\n    abort: () => abortRequest(sendRequest),\n    senderType: XHR_SENDER_TYPE\n  };\n};\nexport default getXhrSend;","map":{"version":3,"names":["logger","FILE_STATES","request","parseResponseHeaders","pick","merge","isPromise","XHR_SENDER_TYPE","MissingUrlError","prepareFormData","SUCCESS_CODES","getRequestData","items","options","data","sendWithFormData","debugLog","length","Error","item","id","file","url","makeRequest","onProgress","config","xhr","issueRequest","requestUrl","requestData","requestOptions","resolvedRequestOptions","preSend","req","upload","onprogress","e","lengthComputable","slice","realPXhr","pXhr","preRequestHandler","count","getXhr","aborted","parseResponseJson","response","headers","parsed","ct","forceJsonResponse","includes","JSON","parse","checkIsResponseSuccessful","isSuccess","isSuccessfulCall","status","Promise","resolve","processResponse","sendRequest","then","state","FINISHED","ERROR","resHeaders","formatServerResponse","catch","error","ABORTED","abortRequest","abortCalled","readyState","abort","getXhrSend","senderType"],"sources":["C:/Users/y2006/OneDrive/바탕 화면/poba/poba/node_modules/@rpldy/sender/lib/esm/xhrSender/xhrSender.js"],"sourcesContent":["import { logger, FILE_STATES, request, parseResponseHeaders, pick, merge, isPromise } from \"@rpldy/shared\";\nimport { XHR_SENDER_TYPE } from \"../consts\";\nimport MissingUrlError from \"../MissingUrlError\";\nimport prepareFormData from \"./prepareFormData\";\nexport const SUCCESS_CODES = [200, 201, 202, 203, 204];\nconst getRequestData = (items, options) => {\n  let data;\n  if (options.sendWithFormData) {\n    logger.debugLog(`uploady.sender: sending ${items.length} item(s) as form data`);\n    data = prepareFormData(items, options);\n  } else {\n    if (items.length > 1) {\n      throw new Error(`XHR Sender - Request without form data can only contain 1 item. received ${items.length}`);\n    }\n    const item = items[0];\n    logger.debugLog(`uploady.sender: sending item ${item.id} as request body`);\n    data = item.file || item.url;\n  }\n  return data;\n};\nconst makeRequest = (items, url, options, onProgress, config) => {\n  let xhr;\n  const data = config?.getRequestData ? config.getRequestData(items, options) : getRequestData(items, options);\n  const issueRequest = (requestUrl = url, requestData = data, requestOptions) => {\n    const resolvedRequestOptions = merge({\n      ...pick(options, [\"method\", \"headers\", \"withCredentials\"]),\n      preSend: req => {\n        req.upload.onprogress = e => {\n          if (e.lengthComputable && onProgress) {\n            onProgress(e, items.slice());\n          }\n        };\n      }\n    }, requestOptions);\n    const realPXhr = request(requestUrl, requestData, resolvedRequestOptions);\n    xhr = realPXhr.xhr;\n    return realPXhr;\n  };\n  const pXhr = config?.preRequestHandler ? config.preRequestHandler(issueRequest, items, url, options, onProgress, config) : issueRequest();\n  return {\n    url,\n    count: items.length,\n    pXhr,\n    getXhr: () => xhr,\n    aborted: false\n  };\n};\nconst parseResponseJson = (response, headers, options) => {\n  let parsed = response;\n  const ct = headers?.[\"content-type\"];\n  if (options.forceJsonResponse || ct?.includes(\"json\")) {\n    try {\n      parsed = JSON.parse(response);\n    } catch {}\n  }\n  return parsed;\n};\nconst checkIsResponseSuccessful = (xhr, options) => {\n  const isSuccess = options.isSuccessfulCall ? options.isSuccessfulCall(xhr) : SUCCESS_CODES.includes(xhr.status);\n  return isPromise(isSuccess) ? isSuccess : Promise.resolve(isSuccess);\n};\nconst processResponse = (sendRequest, options) => sendRequest.pXhr.then(xhr => {\n  logger.debugLog(\"uploady.sender: received upload response \", xhr);\n  return checkIsResponseSuccessful(xhr, options).then(isSuccess => {\n    const state = isSuccess ? FILE_STATES.FINISHED : FILE_STATES.ERROR;\n    const status = xhr.status;\n    const resHeaders = parseResponseHeaders(xhr);\n    const response = {\n      data: options.formatServerResponse?.(xhr.response, status, resHeaders) ?? parseResponseJson(xhr.response, resHeaders, options),\n      headers: resHeaders\n    };\n    return {\n      status,\n      state,\n      response\n    };\n  });\n}).catch(error => {\n  let state, response;\n  if (sendRequest.aborted) {\n    state = FILE_STATES.ABORTED;\n    response = \"aborted\";\n  } else {\n    logger.debugLog(\"uploady.sender: upload failed: \", error);\n    state = FILE_STATES.ERROR;\n    response = error;\n  }\n  return {\n    error: true,\n    state,\n    response,\n    status: 0\n  };\n});\nconst abortRequest = sendRequest => {\n  let abortCalled = false;\n  const {\n    aborted,\n    getXhr\n  } = sendRequest;\n  const xhr = getXhr();\n  if (!aborted && xhr && xhr.readyState && xhr.readyState !== 4) {\n    logger.debugLog(`uploady.sender: cancelling request with ${sendRequest.count} items to: ${sendRequest.url}`);\n    xhr.abort();\n    sendRequest.aborted = true;\n    abortCalled = true;\n  }\n  return abortCalled;\n};\nconst getXhrSend = config => (items, url, options, onProgress) => {\n  if (!url) {\n    throw new MissingUrlError(XHR_SENDER_TYPE);\n  }\n  logger.debugLog(\"uploady.sender: sending file: \", {\n    items,\n    url,\n    options\n  });\n  const sendRequest = makeRequest(items, url, options, onProgress, config);\n  return {\n    request: processResponse(sendRequest, options),\n    abort: () => abortRequest(sendRequest),\n    senderType: XHR_SENDER_TYPE\n  };\n};\nexport default getXhrSend;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}